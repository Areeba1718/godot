/*************************************************************************/
/*  gdscript_function.cpp                                                */
/*************************************************************************/
/*                       This file is part of:                           */
/*                           GODOT ENGINE                                */
/*                      https://godotengine.org                          */
/*************************************************************************/
/* Copyright (c) 2007-2020 Juan Linietsky, Ariel Manzur.                 */
/* Copyright (c) 2014-2020 Godot Engine contributors (cf. AUTHORS.md).   */
/*                                                                       */
/* Permission is hereby granted, free of charge, to any person obtaining */
/* a copy of this software and associated documentation files (the       */
/* "Software"), to deal in the Software without restriction, including   */
/* without limitation the rights to use, copy, modify, merge, publish,   */
/* distribute, sublicense, and/or sell copies of the Software, and to    */
/* permit persons to whom the Software is furnished to do so, subject to */
/* the following conditions:                                             */
/*                                                                       */
/* The above copyright notice and this permission notice shall be        */
/* included in all copies or substantial portions of the Software.       */
/*                                                                       */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
/*************************************************************************/

#include "gdscript_function.h"

#include "core/core_string_names.h"
#include "core/os/os.h"
#include "core/variant_internal.h"
#include "gdscript.h"
#include "gdscript_functions.h"

#ifdef DEBUG_ENABLED
#include "core/string_builder.h"
#endif

Variant *GDScriptFunction::_get_variant(int p_address, GDScriptInstance *p_instance, GDScript *p_script, Variant &self, Variant &static_ref, Variant *p_stack, String &r_error) const {
	int address = p_address & ADDR_MASK;

	//sequential table (jump table generated by compiler)
	switch ((p_address & ADDR_TYPE_MASK) >> ADDR_BITS) {
		case ADDR_TYPE_SELF: {
#ifdef DEBUG_ENABLED
			if (unlikely(!p_instance)) {
				r_error = "Cannot access self without instance.";
				return nullptr;
			}
#endif
			return &self;
		} break;
		case ADDR_TYPE_CLASS: {
			return &static_ref;
		} break;
		case ADDR_TYPE_MEMBER: {
#ifdef DEBUG_ENABLED
			if (unlikely(!p_instance)) {
				r_error = "Cannot access member without instance.";
				return nullptr;
			}
#endif
			//member indexing is O(1)
			return &p_instance->members.write[address];
		} break;
		case ADDR_TYPE_CLASS_CONSTANT: {
			//todo change to index!
			GDScript *s = p_script;
#ifdef DEBUG_ENABLED
			ERR_FAIL_INDEX_V(address, _global_names_count, nullptr);
#endif
			const StringName *sn = &_global_names_ptr[address];

			while (s) {
				GDScript *o = s;
				while (o) {
					Map<StringName, Variant>::Element *E = o->constants.find(*sn);
					if (E) {
						return &E->get();
					}
					o = o->_owner;
				}
				s = s->_base;
			}

			ERR_FAIL_V_MSG(nullptr, "GDScriptCompiler bug.");
		} break;
		case ADDR_TYPE_LOCAL_CONSTANT: {
#ifdef DEBUG_ENABLED
			ERR_FAIL_INDEX_V(address, _constant_count, nullptr);
#endif
			return &_constants_ptr[address];
		} break;
		case ADDR_TYPE_STACK:
		case ADDR_TYPE_STACK_VARIABLE: {
#ifdef DEBUG_ENABLED
			ERR_FAIL_INDEX_V(address, _stack_size, nullptr);
#endif
			return &p_stack[address];
		} break;
		case ADDR_TYPE_GLOBAL: {
#ifdef DEBUG_ENABLED
			ERR_FAIL_INDEX_V(address, GDScriptLanguage::get_singleton()->get_global_array_size(), nullptr);
#endif
			return &GDScriptLanguage::get_singleton()->get_global_array()[address];
		} break;
#ifdef TOOLS_ENABLED
		case ADDR_TYPE_NAMED_GLOBAL: {
#ifdef DEBUG_ENABLED
			ERR_FAIL_INDEX_V(address, _global_names_count, nullptr);
#endif
			StringName id = _global_names_ptr[address];

			if (GDScriptLanguage::get_singleton()->get_named_globals_map().has(id)) {
				return (Variant *)&GDScriptLanguage::get_singleton()->get_named_globals_map()[id];
			} else {
				r_error = "Autoload singleton '" + String(id) + "' has been removed.";
				return nullptr;
			}
		} break;
#endif
		case ADDR_TYPE_NIL: {
			return &nil;
		} break;
	}

	ERR_FAIL_V_MSG(nullptr, "Bad code! (unknown addressing mode).");
	return nullptr;
}

#ifdef DEBUG_ENABLED
static String _get_var_type(const Variant *p_var) {
	String basestr;

	if (p_var->get_type() == Variant::OBJECT) {
		bool was_freed;
		Object *bobj = p_var->get_validated_object_with_check(was_freed);
		if (!bobj) {
			if (was_freed) {
				basestr = "null instance";
			} else {
				basestr = "previously freed";
			}
		} else {
			if (bobj->get_script_instance()) {
				basestr = bobj->get_class() + " (" + bobj->get_script_instance()->get_script()->get_path().get_file() + ")";
			} else {
				basestr = bobj->get_class();
			}
		}

	} else {
		basestr = Variant::get_type_name(p_var->get_type());
	}

	return basestr;
}
#endif // DEBUG_ENABLED

String GDScriptFunction::_get_call_error(const Callable::CallError &p_err, const String &p_where, const Variant **argptrs) const {
	String err_text;

	if (p_err.error == Callable::CallError::CALL_ERROR_INVALID_ARGUMENT) {
		int errorarg = p_err.argument;
		// Handle the Object to Object case separately as we don't have further class details.
#ifdef DEBUG_ENABLED
		if (p_err.expected == Variant::OBJECT && argptrs[errorarg]->get_type() == p_err.expected) {
			err_text = "Invalid type in " + p_where + ". The Object-derived class of argument " + itos(errorarg + 1) + " (" + _get_var_type(argptrs[errorarg]) + ") is not a subclass of the expected argument class.";
		} else
#endif // DEBUG_ENABLED
		{
			err_text = "Invalid type in " + p_where + ". Cannot convert argument " + itos(errorarg + 1) + " from " + Variant::get_type_name(argptrs[errorarg]->get_type()) + " to " + Variant::get_type_name(Variant::Type(p_err.expected)) + ".";
		}
	} else if (p_err.error == Callable::CallError::CALL_ERROR_TOO_MANY_ARGUMENTS) {
		err_text = "Invalid call to " + p_where + ". Expected " + itos(p_err.argument) + " arguments.";
	} else if (p_err.error == Callable::CallError::CALL_ERROR_TOO_FEW_ARGUMENTS) {
		err_text = "Invalid call to " + p_where + ". Expected " + itos(p_err.argument) + " arguments.";
	} else if (p_err.error == Callable::CallError::CALL_ERROR_INVALID_METHOD) {
		err_text = "Invalid call. Nonexistent " + p_where + ".";
	} else if (p_err.error == Callable::CallError::CALL_ERROR_INSTANCE_IS_NULL) {
		err_text = "Attempt to call " + p_where + " on a null instance.";
	} else {
		err_text = "Bug, call error: #" + itos(p_err.error);
	}

	return err_text;
}

#define OPCODE_OP_NUMBER(m_op)              \
	OPCODE_OP_##m_op##_INT_INT,             \
			&&OPCODE_OP_##m_op##_INT_FLOAT, \
			&&OPCODE_OP_##m_op##_FLOAT_INT, \
			&&OPCODE_OP_##m_op##_FLOAT_FLOAT

#define OPCODE_OP_VECTOR(m_op)                      \
	OPCODE_OP_##m_op##_VECTOR2_VECTOR2,             \
			&&OPCODE_OP_##m_op##_VECTOR2I_VECTOR2I, \
			&&OPCODE_OP_##m_op##_VECTOR3_VECTOR3,   \
			&&OPCODE_OP_##m_op##_VECTOR3I_VECTOR3I

#define OPCODE_OP_ARRAYS(m_op)                                              \
	OPCODE_OP_##m_op##_ARRAY_ARRAY,                                         \
			&&OPCODE_OP_##m_op##_PACKED_BYTE_ARRAY_PACKED_BYTE_ARRAY,       \
			&&OPCODE_OP_##m_op##_PACKED_INT32_ARRAY_PACKED_INT32_ARRAY,     \
			&&OPCODE_OP_##m_op##_PACKED_INT64_ARRAY_PACKED_INT64_ARRAY,     \
			&&OPCODE_OP_##m_op##_PACKED_FLOAT32_ARRAY_PACKED_FLOAT32_ARRAY, \
			&&OPCODE_OP_##m_op##_PACKED_FLOAT64_ARRAY_PACKED_FLOAT64_ARRAY, \
			&&OPCODE_OP_##m_op##_PACKED_STRING_ARRAY_PACKED_STRING_ARRAY,   \
			&&OPCODE_OP_##m_op##_PACKED_VECTOR2_ARRAY_PACKED_VECTOR2_ARRAY, \
			&&OPCODE_OP_##m_op##_PACKED_VECTOR3_ARRAY_PACKED_VECTOR3_ARRAY, \
			&&OPCODE_OP_##m_op##_PACKED_COLOR_ARRAY_PACKED_COLOR_ARRAY

#define OPCODE_OP_TYPE_NUMBER(m_op, m_type)      \
	OPCODE_OP_##m_op##_##m_type##_##m_type,      \
			&&OPCODE_OP_##m_op##_##m_type##_INT, \
			&&OPCODE_OP_##m_op##_##m_type##_FLOAT

#define OPCODE_OP_TYPE_NUMBER_REV(m_op, m_type) \
	OPCODE_OP_##m_op##_INT_##m_type,            \
			&&OPCODE_OP_##m_op##_FLOAT_##m_type

#define OPCODE_ALL_TYPES(m_op)                      \
	OPCODE_##m_op##_BOOL,                           \
			&&OPCODE_##m_op##_INT,                  \
			&&OPCODE_##m_op##_FLOAT,                \
			&&OPCODE_##m_op##_STRING,               \
			&&OPCODE_##m_op##_VECTOR2,              \
			&&OPCODE_##m_op##_VECTOR2I,             \
			&&OPCODE_##m_op##_VECTOR3,              \
			&&OPCODE_##m_op##_VECTOR3I,             \
			&&OPCODE_##m_op##_TRANSFORM2D,          \
			&&OPCODE_##m_op##_PLANE,                \
			&&OPCODE_##m_op##_QUAT,                 \
			&&OPCODE_##m_op##_AABB,                 \
			&&OPCODE_##m_op##_BASIS,                \
			&&OPCODE_##m_op##_TRANSFORM,            \
			&&OPCODE_##m_op##_COLOR,                \
			&&OPCODE_##m_op##_STRING_NAME,          \
			&&OPCODE_##m_op##_RID,                  \
			&&OPCODE_##m_op##_OBJECT,               \
			&&OPCODE_##m_op##_CALLABLE,             \
			&&OPCODE_##m_op##_SIGNAL,               \
			&&OPCODE_##m_op##_DICTIONARY,           \
			&&OPCODE_##m_op##_ARRAY,                \
			&&OPCODE_##m_op##_PACKED_BYTE_ARRAY,    \
			&&OPCODE_##m_op##_PACKED_INT32_ARRAY,   \
			&&OPCODE_##m_op##_PACKED_INT64_ARRAY,   \
			&&OPCODE_##m_op##_PACKED_FLOAT32_ARRAY, \
			&&OPCODE_##m_op##_PACKED_FLOAT64_ARRAY, \
			&&OPCODE_##m_op##_PACKED_STRING_ARRAY,  \
			&&OPCODE_##m_op##_PACKED_VECTOR2_ARRAY, \
			&&OPCODE_##m_op##_PACKED_VECTOR3_ARRAY, \
			&&OPCODE_##m_op##_PACKED_COLOR_ARRAY

#if defined(__GNUC__)
#define OPCODES_TABLE                                    \
	static const void *switch_table_ops[] = {            \
		&&OPCODE_OPERATOR,                               \
		&&OPCODE_OP_NUMBER(ADD),                         \
		&&OPCODE_OP_VECTOR(ADD),                         \
		&&OPCODE_OP_ADD_QUAT_QUAT,                       \
		&&OPCODE_OP_ADD_COLOR_COLOR,                     \
		&&OPCODE_OP_CONCAT_STRING_STRING,                \
		&&OPCODE_OP_ARRAYS(CONCAT),                      \
		&&OPCODE_OP_NUMBER(SUBTRACT),                    \
		&&OPCODE_OP_VECTOR(SUBTRACT),                    \
		&&OPCODE_OP_SUBTRACT_QUAT_QUAT,                  \
		&&OPCODE_OP_SUBTRACT_COLOR_COLOR,                \
		&&OPCODE_OP_NUMBER(MULTIPLY),                    \
		&&OPCODE_OP_MULTIPLY_TRANSFORM2D_TRANSFORM2D,    \
		&&OPCODE_OP_MULTIPLY_TRANSFORM2D_VECTOR2,        \
		&&OPCODE_OP_TYPE_NUMBER(MULTIPLY, QUAT),         \
		&&OPCODE_OP_TYPE_NUMBER_REV(MULTIPLY, QUAT),     \
		&&OPCODE_OP_MULTIPLY_QUAT_VECTOR3,               \
		&&OPCODE_OP_TYPE_NUMBER(MULTIPLY, VECTOR2),      \
		&&OPCODE_OP_TYPE_NUMBER_REV(MULTIPLY, VECTOR2),  \
		&&OPCODE_OP_TYPE_NUMBER(MULTIPLY, VECTOR2I),     \
		&&OPCODE_OP_TYPE_NUMBER_REV(MULTIPLY, VECTOR2I), \
		&&OPCODE_OP_TYPE_NUMBER(MULTIPLY, VECTOR3),      \
		&&OPCODE_OP_TYPE_NUMBER_REV(MULTIPLY, VECTOR3),  \
		&&OPCODE_OP_TYPE_NUMBER(MULTIPLY, VECTOR3I),     \
		&&OPCODE_OP_TYPE_NUMBER_REV(MULTIPLY, VECTOR3I), \
		&&OPCODE_OP_TYPE_NUMBER(MULTIPLY, COLOR),        \
		&&OPCODE_OP_TYPE_NUMBER_REV(MULTIPLY, COLOR),    \
		&&OPCODE_OP_NUMBER(DIVIDE),                      \
		&&OPCODE_OP_TYPE_NUMBER(DIVIDE, VECTOR2),        \
		&&OPCODE_OP_TYPE_NUMBER(DIVIDE, VECTOR2I),       \
		&&OPCODE_OP_TYPE_NUMBER(DIVIDE, VECTOR3),        \
		&&OPCODE_OP_TYPE_NUMBER(DIVIDE, VECTOR3I),       \
		&&OPCODE_OP_TYPE_NUMBER(DIVIDE, COLOR),          \
		&&OPCODE_OP_DIVIDE_QUAT_FLOAT,                   \
		&&OPCODE_OP_MODULO_INT_INT,                      \
		&&OPCODE_OP_NEGATE_INT,                          \
		&&OPCODE_OP_NEGATE_FLOAT,                        \
		&&OPCODE_OP_NEGATE_VECTOR2,                      \
		&&OPCODE_OP_NEGATE_VECTOR2I,                     \
		&&OPCODE_OP_NEGATE_VECTOR3,                      \
		&&OPCODE_OP_NEGATE_VECTOR3I,                     \
		&&OPCODE_OP_NEGATE_QUAT,                         \
		&&OPCODE_OP_NEGATE_COLOR,                        \
		&&OPCODE_OP_BIT_NEGATE_INT,                      \
		&&OPCODE_OP_BIT_AND_INT_INT,                     \
		&&OPCODE_OP_BIT_OR_INT_INT,                      \
		&&OPCODE_OP_BIT_XOR_INT_INT,                     \
		&&OPCODE_OP_SHIFT_LEFT,                          \
		&&OPCODE_OP_SHIFT_RIGHT,                         \
		&&OPCODE_OP_NOT,                                 \
		&&OPCODE_OP_AND,                                 \
		&&OPCODE_OP_OR,                                  \
		&&OPCODE_ALL_TYPES(OP_EQUAL),                    \
		&&OPCODE_OP_EQUAL_INT_FLOAT,                     \
		&&OPCODE_OP_EQUAL_FLOAT_INT,                     \
		&&OPCODE_OP_EQUAL_STRING_STRING_NAME,            \
		&&OPCODE_OP_EQUAL_STRING_NAME_STRING,            \
		&&OPCODE_OP_EQUAL_STRING_NODE_PATH,              \
		&&OPCODE_OP_EQUAL_NODE_PATH_STRING,              \
		&&OPCODE_ALL_TYPES(OP_NOT_EQUAL),                \
		&&OPCODE_OP_NOT_EQUAL_INT_FLOAT,                 \
		&&OPCODE_OP_NOT_EQUAL_FLOAT_INT,                 \
		&&OPCODE_OP_NOT_EQUAL_STRING_STRING_NAME,        \
		&&OPCODE_OP_NOT_EQUAL_STRING_NAME_STRING,        \
		&&OPCODE_OP_NOT_EQUAL_STRING_NODE_PATH,          \
		&&OPCODE_OP_NOT_EQUAL_NODE_PATH_STRING,          \
		&&OPCODE_OP_LESS_BOOL_BOOL,                      \
		&&OPCODE_OP_NUMBER(LESS),                        \
		&&OPCODE_OP_VECTOR(LESS),                        \
		&&OPCODE_OP_NUMBER(LESS_EQUAL),                  \
		&&OPCODE_OP_VECTOR(LESS_EQUAL),                  \
		&&OPCODE_OP_GREATER_BOOL_BOOL,                   \
		&&OPCODE_OP_NUMBER(GREATER),                     \
		&&OPCODE_OP_VECTOR(GREATER),                     \
		&&OPCODE_OP_NUMBER(GREATER_EQUAL),               \
		&&OPCODE_OP_VECTOR(GREATER_EQUAL),               \
		&&OPCODE_EXTENDS_TEST,                           \
		&&OPCODE_IS_BUILTIN,                             \
		&&OPCODE_SET,                                    \
		&&OPCODE_GET,                                    \
		&&OPCODE_GET_STRING_INT,                         \
		&&OPCODE_GET_STRING_FLOAT,                       \
		&&OPCODE_GET_VECTOR2_INT,                        \
		&&OPCODE_GET_VECTOR2_FLOAT,                      \
		&&OPCODE_GET_VECTOR2_STRING,                     \
		&&OPCODE_GET_VECTOR2I_INT,                       \
		&&OPCODE_GET_VECTOR2I_FLOAT,                     \
		&&OPCODE_GET_VECTOR2I_STRING,                    \
		&&OPCODE_GET_VECTOR3_INT,                        \
		&&OPCODE_GET_VECTOR3_FLOAT,                      \
		&&OPCODE_GET_VECTOR3_STRING,                     \
		&&OPCODE_GET_VECTOR3I_INT,                       \
		&&OPCODE_GET_VECTOR3I_FLOAT,                     \
		&&OPCODE_GET_VECTOR3I_STRING,                    \
		&&OPCODE_GET_RECT2_STRING,                       \
		&&OPCODE_GET_RECT2I_STRING,                      \
		&&OPCODE_GET_TRANSFORM_INT,                      \
		&&OPCODE_GET_TRANSFORM_FLOAT,                    \
		&&OPCODE_GET_TRANSFORM_STRING,                   \
		&&OPCODE_GET_TRANSFORM2D_INT,                    \
		&&OPCODE_GET_TRANSFORM2D_FLOAT,                  \
		&&OPCODE_GET_TRANSFORM2D_STRING,                 \
		&&OPCODE_GET_PLANE_STRING,                       \
		&&OPCODE_GET_QUAT_STRING,                        \
		&&OPCODE_GET_AABB_STRING,                        \
		&&OPCODE_GET_BASIS_INT,                          \
		&&OPCODE_GET_BASIS_FLOAT,                        \
		&&OPCODE_GET_BASIS_STRING,                       \
		&&OPCODE_GET_COLOR_INT,                          \
		&&OPCODE_GET_COLOR_FLOAT,                        \
		&&OPCODE_GET_COLOR_STRING,                       \
		&&OPCODE_GET_OBJECT_STRING,                      \
		&&OPCODE_SET_NAMED,                              \
		&&OPCODE_GET_NAMED,                              \
		&&OPCODE_GET_NAMED_VECTOR2,                      \
		&&OPCODE_GET_NAMED_VECTOR2I,                     \
		&&OPCODE_GET_NAMED_VECTOR3,                      \
		&&OPCODE_GET_NAMED_VECTOR3I,                     \
		&&OPCODE_GET_NAMED_RECT2,                        \
		&&OPCODE_GET_NAMED_RECT2I,                       \
		&&OPCODE_GET_NAMED_TRANSFORM,                    \
		&&OPCODE_GET_NAMED_TRANSFORM2D,                  \
		&&OPCODE_GET_NAMED_PLANE,                        \
		&&OPCODE_GET_NAMED_QUAT,                         \
		&&OPCODE_GET_NAMED_BASIS,                        \
		&&OPCODE_GET_NAMED_AABB,                         \
		&&OPCODE_GET_NAMED_COLOR,                        \
		&&OPCODE_GET_NAMED_OBJECT,                       \
		&&OPCODE_SET_MEMBER,                             \
		&&OPCODE_GET_MEMBER,                             \
		&&OPCODE_ASSIGN,                                 \
		&&OPCODE_ASSIGN_TRUE,                            \
		&&OPCODE_ASSIGN_FALSE,                           \
		&&OPCODE_ASSIGN_TYPED_BUILTIN,                   \
		&&OPCODE_ASSIGN_TYPED_NATIVE,                    \
		&&OPCODE_ASSIGN_TYPED_SCRIPT,                    \
		&&OPCODE_CAST_TO_BUILTIN,                        \
		&&OPCODE_CAST_TO_NATIVE,                         \
		&&OPCODE_CAST_TO_SCRIPT,                         \
		&&OPCODE_CONSTRUCT,                              \
		&&OPCODE_CONSTRUCT_ARRAY,                        \
		&&OPCODE_CONSTRUCT_DICTIONARY,                   \
		&&OPCODE_CALL,                                   \
		&&OPCODE_CALL_RETURN,                            \
		&&OPCODE_CALL_ASYNC,                             \
		&&OPCODE_CALL_BUILT_IN,                          \
		&&OPCODE_CALL_SELF_BASE,                         \
		&&OPCODE_AWAIT,                                  \
		&&OPCODE_AWAIT_RESUME,                           \
		&&OPCODE_JUMP,                                   \
		&&OPCODE_JUMP_IF,                                \
		&&OPCODE_JUMP_IF_NOT,                            \
		&&OPCODE_JUMP_TO_DEF_ARGUMENT,                   \
		&&OPCODE_RETURN,                                 \
		&&OPCODE_ITERATE_BEGIN,                          \
		&&OPCODE_ITERATE,                                \
		&&OPCODE_ASSERT,                                 \
		&&OPCODE_BREAKPOINT,                             \
		&&OPCODE_LINE,                                   \
		&&OPCODE_END                                     \
	};                                                   \
	static_assert((sizeof(switch_table_ops) / sizeof(switch_table_ops[0]) == (OPCODE_END + 1)), "Opcodes in jump table aren't the same as opcodes in enum.");

#define OPCODE(m_op) \
	m_op:
#define OPCODE_WHILE(m_test)
#define OPCODES_END \
	OPSEXIT:
#define OPCODES_OUT \
	OPSOUT:
#define DISPATCH_OPCODE goto *switch_table_ops[_code_ptr[ip]]
#define OPCODE_SWITCH(m_test) DISPATCH_OPCODE;
#define OPCODE_BREAK goto OPSEXIT
#define OPCODE_OUT goto OPSOUT
#else
#define OPCODES_TABLE
#define OPCODE(m_op) case m_op:
#define OPCODE_WHILE(m_test) while (m_test)
#define OPCODES_END
#define OPCODES_OUT
#define DISPATCH_OPCODE continue
#define OPCODE_SWITCH(m_test) switch (m_test)
#define OPCODE_BREAK break
#define OPCODE_OUT break
#endif

Variant GDScriptFunction::call(GDScriptInstance *p_instance, const Variant **p_args, int p_argcount, Callable::CallError &r_err, CallState *p_state) {
	OPCODES_TABLE;

	if (!_code_ptr) {
		return Variant();
	}

	r_err.error = Callable::CallError::CALL_OK;

	Variant self;
	Variant static_ref;
	Variant retvalue;
	Variant *stack = nullptr;
	Variant **call_args;
	int defarg = 0;

#ifdef DEBUG_ENABLED

	//GDScriptLanguage::get_singleton()->calls++;

#endif

	uint32_t alloca_size = 0;
	GDScript *script;
	int ip = 0;
	int line = _initial_line;

	if (p_state) {
		//use existing (supplied) state (awaited)
		stack = (Variant *)p_state->stack.ptr();
		call_args = (Variant **)&p_state->stack.ptr()[sizeof(Variant) * p_state->stack_size]; //ptr() to avoid bounds check
		line = p_state->line;
		ip = p_state->ip;
		alloca_size = p_state->stack.size();
		script = p_state->script;
		p_instance = p_state->instance;
		defarg = p_state->defarg;
		self = p_state->self;

	} else {
		if (p_argcount != _argument_count) {
			if (p_argcount > _argument_count) {
				r_err.error = Callable::CallError::CALL_ERROR_TOO_MANY_ARGUMENTS;
				r_err.argument = _argument_count;

				return Variant();
			} else if (p_argcount < _argument_count - _default_arg_count) {
				r_err.error = Callable::CallError::CALL_ERROR_TOO_FEW_ARGUMENTS;
				r_err.argument = _argument_count - _default_arg_count;
				return Variant();
			} else {
				defarg = _argument_count - p_argcount;
			}
		}

		alloca_size = sizeof(Variant *) * _call_size + sizeof(Variant) * _stack_size;

		if (alloca_size) {
			uint8_t *aptr = (uint8_t *)alloca(alloca_size);

			if (_stack_size) {
				stack = (Variant *)aptr;
				for (int i = 0; i < p_argcount; i++) {
					if (!argument_types[i].has_type) {
						memnew_placement(&stack[i], Variant(*p_args[i]));
						continue;
					}

					if (!argument_types[i].is_type(*p_args[i], true)) {
						r_err.error = Callable::CallError::CALL_ERROR_INVALID_ARGUMENT;
						r_err.argument = i;
						r_err.expected = argument_types[i].kind == GDScriptDataType::BUILTIN ? argument_types[i].builtin_type : Variant::OBJECT;
						return Variant();
					}
					if (argument_types[i].kind == GDScriptDataType::BUILTIN) {
						Variant arg = Variant::construct(argument_types[i].builtin_type, &p_args[i], 1, r_err);
						memnew_placement(&stack[i], Variant(arg));
					} else {
						memnew_placement(&stack[i], Variant(*p_args[i]));
					}
				}
				for (int i = p_argcount; i < _stack_size; i++) {
					memnew_placement(&stack[i], Variant);
				}
			} else {
				stack = nullptr;
			}

			if (_call_size) {
				call_args = (Variant **)&aptr[sizeof(Variant) * _stack_size];
			} else {
				call_args = nullptr;
			}

		} else {
			stack = nullptr;
			call_args = nullptr;
		}

		if (p_instance) {
			if (p_instance->base_ref && static_cast<Reference *>(p_instance->owner)->is_referenced()) {
				self = REF(static_cast<Reference *>(p_instance->owner));
			} else {
				self = p_instance->owner;
			}
			script = p_instance->script.ptr();
		} else {
			script = _script;
		}
	}

	static_ref = script;

	String err_text;

#ifdef DEBUG_ENABLED

	if (EngineDebugger::is_active()) {
		GDScriptLanguage::get_singleton()->enter_function(p_instance, this, stack, &ip, &line);
	}

#define GD_ERR_BREAK(m_cond)                                                                                           \
	{                                                                                                                  \
		if (unlikely(m_cond)) {                                                                                        \
			_err_print_error(FUNCTION_STR, __FILE__, __LINE__, "Condition ' " _STR(m_cond) " ' is true. Breaking..:"); \
			OPCODE_BREAK;                                                                                              \
		}                                                                                                              \
	}

#define CHECK_SPACE(m_space) \
	GD_ERR_BREAK((ip + m_space) > _code_size)

#define GET_VARIANT_PTR(m_v, m_code_ofs)                                                                   \
	Variant *m_v;                                                                                          \
	m_v = _get_variant(_code_ptr[ip + m_code_ofs], p_instance, script, self, static_ref, stack, err_text); \
	if (unlikely(!m_v))                                                                                    \
		OPCODE_BREAK;

#else
#define GD_ERR_BREAK(m_cond)
#define CHECK_SPACE(m_space)
#define GET_VARIANT_PTR(m_v, m_code_ofs) \
	Variant *m_v;                        \
	m_v = _get_variant(_code_ptr[ip + m_code_ofs], p_instance, script, self, static_ref, stack, err_text);

#endif

#ifdef DEBUG_ENABLED

	uint64_t function_start_time = 0;
	uint64_t function_call_time = 0;

	if (GDScriptLanguage::get_singleton()->profiling) {
		function_start_time = OS::get_singleton()->get_ticks_usec();
		function_call_time = 0;
		profile.call_count++;
		profile.frame_call_count++;
	}
	bool exit_ok = false;
	bool awaited = false;
#endif

// Helpers for VariantInternal methods in macros.
#define OP_GET_BOOL get_bool
#define OP_GET_INT get_int
#define OP_GET_FLOAT get_float
#define OP_GET_VECTOR2 get_vector2
#define OP_GET_VECTOR2I get_vector2i
#define OP_GET_VECTOR3 get_vector3
#define OP_GET_VECTOR3I get_vector3i
#define OP_GET_RECT2 get_rect2
#define OP_GET_RECT2I get_rect2i
#define OP_GET_QUAT get_quat
#define OP_GET_COLOR get_color
#define OP_GET_STRING get_string
#define OP_GET_STRING_NAME get_string_name
#define OP_GET_NODE_PATH get_node_path
#define OP_GET_CALLABLE get_callable
#define OP_GET_SIGNAL get_signal
#define OP_GET_ARRAY get_array
#define OP_GET_DICTIONARY get_dictionary
#define OP_GET_PACKED_BYTE_ARRAY get_byte_array
#define OP_GET_PACKED_INT32_ARRAY get_int32_array
#define OP_GET_PACKED_INT64_ARRAY get_int64_array
#define OP_GET_PACKED_FLOAT32_ARRAY get_float32_array
#define OP_GET_PACKED_FLOAT64_ARRAY get_float64_array
#define OP_GET_PACKED_STRING_ARRAY get_string_array
#define OP_GET_PACKED_VECTOR2_ARRAY get_vector2_array
#define OP_GET_PACKED_VECTOR3_ARRAY get_vector3_array
#define OP_GET_PACKED_COLOR_ARRAY get_color_array
#define OP_GET_TRANSFORM get_transform
#define OP_GET_TRANSFORM2D get_transform2d
#define OP_GET_PLANE get_plane
#define OP_GET_AABB get_aabb
#define OP_GET_BASIS get_basis
#define OP_GET_RID get_rid

#define OPCODE_OP_NAMED(m_op_name, m_op, m_type_a, m_type_b, m_type_dst)                                                                  \
	OPCODE(OPCODE_##m_op_name) {                                                                                                          \
		CHECK_SPACE(4);                                                                                                                   \
		GET_VARIANT_PTR(a, 1);                                                                                                            \
		GET_VARIANT_PTR(b, 2);                                                                                                            \
		GET_VARIANT_PTR(dst, 3);                                                                                                          \
		VariantInternal::initialize(dst, Variant::m_type_dst);                                                                            \
		*VariantInternal::OP_GET_##m_type_dst(dst) = *VariantInternal::OP_GET_##m_type_a(a) m_op * VariantInternal::OP_GET_##m_type_b(b); \
		ip += 4;                                                                                                                          \
	}                                                                                                                                     \
	DISPATCH_OPCODE

#define OPCODE_OP_MATH_TYPE(m_op_name, m_op, m_type_a, m_type_b, m_type_dst) \
	OPCODE_OP_NAMED(OP_##m_op_name##_##m_type_a##_##m_type_b, m_op, m_type_a, m_type_b, m_type_dst)

#define OPCODE_OP_CALL_TYPE(m_op_name, m_func, m_type_a, m_type_b, m_type_dst)                                                              \
	OPCODE(OPCODE_OP_##m_op_name##_##m_type_a##_##m_type_b) {                                                                               \
		CHECK_SPACE(4);                                                                                                                     \
		GET_VARIANT_PTR(a, 1);                                                                                                              \
		GET_VARIANT_PTR(b, 2);                                                                                                              \
		GET_VARIANT_PTR(dst, 3);                                                                                                            \
		VariantInternal::initialize(dst, Variant::m_type_dst);                                                                              \
		*VariantInternal::OP_GET_##m_type_dst(dst) = VariantInternal::OP_GET_##m_type_a(a)->m_func(*VariantInternal::OP_GET_##m_type_b(b)); \
		ip += 4;                                                                                                                            \
	}                                                                                                                                       \
	DISPATCH_OPCODE

#define OPCODE_OP_NO_INIT_TYPE(m_op_name, m_op, m_type_a, m_type_b)                                 \
	OPCODE(OPCODE_OP_##m_op_name##_##m_type_a##_##m_type_b) {                                       \
		CHECK_SPACE(4);                                                                             \
		GET_VARIANT_PTR(a, 1);                                                                      \
		GET_VARIANT_PTR(b, 2);                                                                      \
		GET_VARIANT_PTR(dst, 3);                                                                    \
		*dst = *VariantInternal::OP_GET_##m_type_a(a) m_op * VariantInternal::OP_GET_##m_type_b(b); \
		ip += 4;                                                                                    \
	}                                                                                               \
	DISPATCH_OPCODE

#define OPCODE_OP_MATH_NUMBER(m_op_name, m_op)               \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, INT, INT, INT);     \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, INT, FLOAT, FLOAT); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, FLOAT, INT, FLOAT); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, FLOAT, FLOAT, FLOAT)

#define OPCODE_OP_MATH_VECTOR(m_op_name, m_op)                          \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR2, VECTOR2, VECTOR2);    \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR2I, VECTOR2I, VECTOR2I); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR3, VECTOR3, VECTOR3);    \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR3I, VECTOR3I, VECTOR3I)

#define OPCODE_OP_MATH_WITH_NUMBERS(m_op_name, m_op, m_type)      \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, m_type, m_type, m_type); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, m_type, INT, m_type);    \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, m_type, FLOAT, m_type);

#define OPCODE_OP_MATH_WITH_NUMBERS_REV(m_op_name, m_op, m_type) \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, INT, m_type, m_type);   \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, FLOAT, m_type, m_type)

#define OPCODE_OP_CONCAT_ARRAYS(m_type, m_vec_type)                                       \
	OPCODE(OPCODE_OP_CONCAT_##m_type##_ARRAY_##m_type##_ARRAY) {                          \
		CHECK_SPACE(4);                                                                   \
		GET_VARIANT_PTR(a, 1);                                                            \
		GET_VARIANT_PTR(b, 2);                                                            \
		GET_VARIANT_PTR(dst, 3);                                                          \
		const Vector<m_vec_type> &array_a = *VariantInternal::OP_GET_##m_type##_ARRAY(a); \
		const Vector<m_vec_type> &array_b = *VariantInternal::OP_GET_##m_type##_ARRAY(b); \
		Vector<m_vec_type> sum = array_a;                                                 \
		sum.append_array(array_b);                                                        \
		*dst = sum;                                                                       \
		ip += 4;                                                                          \
	}                                                                                     \
	DISPATCH_OPCODE

#define OPCODE_ARRAYS_MACRO(m_macro)  \
	m_macro(PACKED_BYTE, uint8_t);    \
	m_macro(PACKED_INT32, int32_t);   \
	m_macro(PACKED_INT64, int64_t);   \
	m_macro(PACKED_FLOAT32, float);   \
	m_macro(PACKED_FLOAT64, double);  \
	m_macro(PACKED_STRING, String);   \
	m_macro(PACKED_VECTOR2, Vector2); \
	m_macro(PACKED_VECTOR3, Vector3); \
	m_macro(PACKED_COLOR, Color)

#define OPCODE_ALL_TYPES_BUT_OBJECT_MACRO(m_macro) \
	m_macro(BOOL);                                 \
	m_macro(INT);                                  \
	m_macro(FLOAT);                                \
	m_macro(STRING);                               \
	m_macro(VECTOR2);                              \
	m_macro(VECTOR2I);                             \
	m_macro(VECTOR3);                              \
	m_macro(VECTOR3I);                             \
	m_macro(TRANSFORM2D);                          \
	m_macro(PLANE);                                \
	m_macro(QUAT);                                 \
	m_macro(AABB);                                 \
	m_macro(BASIS);                                \
	m_macro(TRANSFORM);                            \
	m_macro(COLOR);                                \
	m_macro(STRING_NAME);                          \
	m_macro(RID);                                  \
	m_macro(CALLABLE);                             \
	m_macro(SIGNAL);                               \
	m_macro(DICTIONARY)

#define OPCODE_OP_UNARY(m_op_name, m_op, m_type)                                             \
	OPCODE(OPCODE_OP_##m_op_name##_##m_type) {                                               \
		CHECK_SPACE(3);                                                                      \
		GET_VARIANT_PTR(a, 1);                                                               \
		GET_VARIANT_PTR(dst, 2);                                                             \
		VariantInternal::initialize(dst, Variant::m_type);                                   \
		*VariantInternal::OP_GET_##m_type(dst) = m_op * VariantInternal::OP_GET_##m_type(a); \
		ip += 3;                                                                             \
	}                                                                                        \
	DISPATCH_OPCODE

#define OPCODE_OP_LOGIC_UNARY(m_op_name, m_op)                   \
	OPCODE(OPCODE_OP_##m_op_name) {                              \
		CHECK_SPACE(3);                                          \
		GET_VARIANT_PTR(a, 1);                                   \
		GET_VARIANT_PTR(dst, 2);                                 \
		VariantInternal::initialize(dst, Variant::BOOL);         \
		*VariantInternal::get_bool(dst) = m_op(a->booleanize()); \
		ip += 3;                                                 \
	}                                                            \
	DISPATCH_OPCODE

#define OPCODE_OP_LOGIC_BINARY(m_op_name, m_op)                                 \
	OPCODE(OPCODE_OP_##m_op_name) {                                             \
		CHECK_SPACE(4);                                                         \
		GET_VARIANT_PTR(a, 1);                                                  \
		GET_VARIANT_PTR(b, 2);                                                  \
		GET_VARIANT_PTR(dst, 3);                                                \
		VariantInternal::initialize(dst, Variant::BOOL);                        \
		*VariantInternal::get_bool(dst) = a->booleanize() m_op b->booleanize(); \
		ip += 4;                                                                \
	}                                                                           \
	DISPATCH_OPCODE

#define OPCODE_EQUAL_TYPE(m_type) \
	OPCODE_OP_NAMED(OP_EQUAL_##m_type, ==, m_type, m_type, BOOL)

#define OPCODE_EQUAL_TYPES(m_type_a, m_type_b) \
	OPCODE_OP_MATH_TYPE(EQUAL, ==, m_type_a, m_type_b, BOOL)

#define OPCODE_NOT_EQUAL_TYPE(m_type) \
	OPCODE_OP_NAMED(OP_NOT_EQUAL_##m_type, !=, m_type, m_type, BOOL)

#define OPCODE_NOT_EQUAL_TYPES(m_type_a, m_type_b) \
	OPCODE_OP_MATH_TYPE(NOT_EQUAL, !=, m_type_a, m_type_b, BOOL)

#define OP_ARRAYS_OP_BODY_TEST(m_type, m_vec_type, m_op, m_res_if_less)               \
	const Vector<m_vec_type> &array_a = *VariantInternal::OP_GET_##m_type##_ARRAY(a); \
	const Vector<m_vec_type> &array_b = *VariantInternal::OP_GET_##m_type##_ARRAY(b); \
	int a_len = array_a.size();                                                       \
	if (a_len < array_b.size()) {                                                     \
		*VariantInternal::get_bool(dst) = m_res_if_less;                              \
	} else {                                                                          \
		bool passed = true;                                                           \
		const m_vec_type *ra = array_a.ptr();                                         \
		const m_vec_type *rb = array_b.ptr();                                         \
		for (int i = 0; i < a_len; i++) {                                             \
			if (ra[i] m_op rb[i]) {                                                   \
				passed = false;                                                       \
				break;                                                                \
			}                                                                         \
		}                                                                             \
		*VariantInternal::get_bool(dst) = passed;                                     \
	}

#define OP_ARRAY_OP_BODY_TEST(m_op, m_res_if_less)        \
	const Array *array_a = VariantInternal::get_array(a); \
	const Array *array_b = VariantInternal::get_array(b); \
	int a_len = array_a->size();                          \
	if (a_len < array_b->size()) {                        \
		*VariantInternal::get_bool(dst) = m_res_if_less;  \
	} else {                                              \
		bool passed = true;                               \
		for (int i = 0; i < a_len; i++) {                 \
			if ((*array_a)[i] m_op(*array_b)[i]) {        \
				passed = false;                           \
				break;                                    \
			}                                             \
		}                                                 \
		*VariantInternal::get_bool(dst) = passed;         \
	}

#define OP_OBJECT_EQUAL_BODY_TEST(m_not)                                                             \
	bool equal = false;                                                                              \
	if (b->get_type() == Variant::NIL) {                                                             \
		equal = a->get_type() == Variant::NIL || (a->operator Object *() == nullptr);                \
	} else {                                                                                         \
		equal = a->get_type() != Variant::NIL && (a->operator Object *() == b->operator Object *()); \
	}                                                                                                \
	*VariantInternal::get_bool(dst) m_not equal;

#define OPCODE_OP_COMPARISON_BODY(m_op_name, m_body)     \
	OPCODE(OPCODE_OP_##m_op_name) {                      \
		CHECK_SPACE(4);                                  \
		GET_VARIANT_PTR(a, 1);                           \
		GET_VARIANT_PTR(b, 2);                           \
		GET_VARIANT_PTR(dst, 3);                         \
		VariantInternal::initialize(dst, Variant::BOOL); \
		m_body                                           \
				ip += 4;                                 \
	}                                                    \
	DISPATCH_OPCODE

#define OPCODE_OP_EQUAL_ARRAYS(m_op_name, m_type, m_vec_type) \
	OPCODE_OP_COMPARISON_BODY(m_op_name##_##m_type##_ARRAY, OP_ARRAYS_OP_BODY_TEST(m_type, m_vec_type, !=, false))

#define OPCODE_OP_NOT_EQUAL_ARRAYS(m_op_name, m_type, m_vec_type) \
	OPCODE_OP_COMPARISON_BODY(m_op_name##_##m_type##_ARRAY, OP_ARRAYS_OP_BODY_TEST(m_type, m_vec_type, ==, false))

#define OPCODE_ARRAYS_COMPARISON_MACRO(m_op_name, m_macro) \
	m_macro(m_op_name, PACKED_BYTE, uint8_t);              \
	m_macro(m_op_name, PACKED_INT32, int32_t);             \
	m_macro(m_op_name, PACKED_INT64, int64_t);             \
	m_macro(m_op_name, PACKED_FLOAT32, float);             \
	m_macro(m_op_name, PACKED_FLOAT64, double);            \
	m_macro(m_op_name, PACKED_STRING, String);             \
	m_macro(m_op_name, PACKED_VECTOR2, Vector2);           \
	m_macro(m_op_name, PACKED_VECTOR3, Vector3);           \
	m_macro(m_op_name, PACKED_COLOR, Color)

#define OPCODE_OP_COMP_NUMBER(m_op_name, m_op)              \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, INT, INT, BOOL);   \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, INT, FLOAT, BOOL); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, FLOAT, INT, BOOL); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, FLOAT, FLOAT, BOOL)

#define OPCODE_OP_COMP_VECTOR(m_op_name, m_op)                      \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR2, VECTOR2, BOOL);   \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR2I, VECTOR2I, BOOL); \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR3, VECTOR3, BOOL);   \
	OPCODE_OP_MATH_TYPE(m_op_name, m_op, VECTOR3I, VECTOR3I, BOOL)

#ifdef DEBUG_ENABLED
#define OPCODE_GET_NUMBER_INDEX_LIMIT(m_type, m_var_type, m_user_type, m_idx_type, m_limit, m_ret_type) \
	OPCODE(OPCODE_GET_##m_var_type##_##m_idx_type) {                                                    \
		CHECK_SPACE(3);                                                                                 \
		GET_VARIANT_PTR(src, 1);                                                                        \
		GET_VARIANT_PTR(index, 2);                                                                      \
		GET_VARIANT_PTR(dst, 3);                                                                        \
		m_type *source = VariantInternal::OP_GET_##m_var_type(src);                                     \
		int64_t idx = *VariantInternal::OP_GET_##m_idx_type(index);                                     \
		if (idx < 0) {                                                                                  \
			idx += m_limit;                                                                             \
		}                                                                                               \
		if (idx < 0 || idx >= m_limit) {                                                                \
			err_text = vformat(R"(Trying to access index "%d" past end of m_user_type.)", idx);         \
			OPCODE_BREAK;                                                                               \
		}                                                                                               \
		VariantInternal::initialize(dst, Variant::m_ret_type);                                          \
		*VariantInternal::OP_GET_##m_ret_type(dst) = (*source)[idx];                                    \
		ip += 4;                                                                                        \
	}                                                                                                   \
	DISPATCH_OPCODE
#else
#define OPCODE_GET_NUMBER_INDEX_LIMIT(m_type, m_var_type, m_user_type, m_idx_type, m_limit, m_ret_type) \
	OPCODE(OPCODE_GET_##m_var_type##_##m_idx_type) {                                                    \
		CHECK_SPACE(3);                                                                                 \
		GET_VARIANT_PTR(src, 1);                                                                        \
		GET_VARIANT_PTR(index, 2);                                                                      \
		GET_VARIANT_PTR(dst, 3);                                                                        \
		m_type *source = VariantInternal::OP_GET_##m_var_type(src);                                     \
		int64_t idx = *VariantInternal::OP_GET_##m_idx_type(index);                                     \
		if (idx < 0) {                                                                                  \
			idx += m_limit;                                                                             \
		}                                                                                               \
		VariantInternal::initialize(dst, Variant::m_ret_type);                                          \
		*VariantInternal::OP_GET_##m_ret_type(dst) = (*source)[idx];                                    \
		ip += 4;                                                                                        \
	}                                                                                                   \
	DISPATCH_OPCODE
#endif

#ifdef DEBUG_ENABLED
#define OPCODE_OP_SHIFT_ERR err_text = "Cannot shift less than 0 or more than 64 bits.";
#else
#define OPCODE_OP_SHIFT_ERR
#endif
#define OPCODE_OP_SHIFT(m_op_name, m_op)                                                                  \
	OPCODE(OPCODE_OP_##m_op_name) {                                                                       \
		CHECK_SPACE(4);                                                                                   \
		GET_VARIANT_PTR(a, 1);                                                                            \
		GET_VARIANT_PTR(b, 2);                                                                            \
		GET_VARIANT_PTR(dst, 3);                                                                          \
		int b_int = *VariantInternal::get_int(b);                                                         \
		if (b_int < 0 || b_int >= 64) {                                                                   \
			OPCODE_OP_SHIFT_ERR                                                                           \
			OPCODE_BREAK;                                                                                 \
		}                                                                                                 \
		VariantInternal::initialize(dst, Variant::INT);                                                   \
		*VariantInternal::get_int(dst) = *VariantInternal::get_int(a) m_op * VariantInternal::get_int(b); \
		ip += 4;                                                                                          \
	}                                                                                                     \
	DISPATCH_OPCODE

#define OPCODE_INIT_RESULT(m_type, m_var_type)             \
	VariantInternal::initialize(dst, Variant::m_var_type); \
	m_type *result = VariantInternal::OP_GET_##m_var_type(dst)

#define OPCODE_GET_NAMED_START_SINGLE_RET(m_type, m_var_type, m_ret_type, m_ret_var_type) \
	CHECK_SPACE(4);                                                                       \
	GET_VARIANT_PTR(src, 1);                                                              \
	GET_VARIANT_PTR(dst, 3);                                                              \
	int indexname = _code_ptr[ip + 2];                                                    \
	GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count);                      \
	const StringName *index = &_global_names_ptr[indexname];                              \
	m_type *source = VariantInternal::OP_GET_##m_var_type(src);                           \
	VariantInternal::initialize(dst, Variant::m_ret_var_type);                            \
	m_ret_type *result = VariantInternal::OP_GET_##m_ret_var_type(dst)

#define OPCODE_GET_NAMED_START(m_type, m_var_type)                   \
	CHECK_SPACE(4);                                                  \
	GET_VARIANT_PTR(src, 1);                                         \
	GET_VARIANT_PTR(dst, 3);                                         \
	int indexname = _code_ptr[ip + 2];                               \
	GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count); \
	const StringName *index = &_global_names_ptr[indexname];         \
	m_type *source = VariantInternal::OP_GET_##m_var_type(src)

#define OPCODE_GET_NAMED_ERROR()                                                                                                                                                                                               \
	if (src->has_method(*index)) {                                                                                                                                                                                             \
		err_text = "Invalid get index '" + index->operator String() + "' (on base: '" + _get_var_type(src) + "'). Did you mean '." + index->operator String() + "()' or funcref(obj, \"" + index->operator String() + "\") ?"; \
	} else {                                                                                                                                                                                                                   \
		err_text = "Invalid get index '" + index->operator String() + "' (on base: '" + _get_var_type(src) + "').";                                                                                                            \
	}                                                                                                                                                                                                                          \
	OPCODE_BREAK

#ifdef DEBUG_ENABLED
	OPCODE_WHILE(ip < _code_size) {
		int last_opcode = _code_ptr[ip];
#else
	OPCODE_WHILE(true) {
#endif

		OPCODE_SWITCH(_code_ptr[ip]) {
			OPCODE(OPCODE_OPERATOR) {
				CHECK_SPACE(5);

				bool valid;
				Variant::Operator op = (Variant::Operator)_code_ptr[ip + 1];
				GD_ERR_BREAK(op >= Variant::OP_MAX);

				GET_VARIANT_PTR(a, 2);
				GET_VARIANT_PTR(b, 3);
				GET_VARIANT_PTR(dst, 4);

#ifdef DEBUG_ENABLED

				Variant ret;
				Variant::evaluate(op, *a, *b, ret, valid);
#else
				Variant::evaluate(op, *a, *b, *dst, valid);
#endif
#ifdef DEBUG_ENABLED
				if (!valid) {
					if (ret.get_type() == Variant::STRING) {
						//return a string when invalid with the error
						err_text = ret;
						err_text += " in operator '" + Variant::get_operator_name(op) + "'.";
					} else {
						err_text = "Invalid operands '" + Variant::get_type_name(a->get_type()) + "' and '" + Variant::get_type_name(b->get_type()) + "' in operator '" + Variant::get_operator_name(op) + "'.";
					}
					OPCODE_BREAK;
				}
				*dst = ret;
#endif
				ip += 5;
			}
			DISPATCH_OPCODE;

			// Typed operations.
			// Addition.
			OPCODE_OP_MATH_NUMBER(ADD, +);
			OPCODE_OP_MATH_VECTOR(ADD, +);
			OPCODE_OP_MATH_TYPE(ADD, +, QUAT, QUAT, QUAT);
			OPCODE_OP_MATH_TYPE(ADD, +, COLOR, COLOR, COLOR);
			OPCODE_OP_NO_INIT_TYPE(CONCAT, +, STRING, STRING);
			OPCODE(OPCODE_OP_CONCAT_ARRAY_ARRAY) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(a, 1);
				GET_VARIANT_PTR(b, 2);
				GET_VARIANT_PTR(dst, 3);

				const Array &array_a = *VariantInternal::get_array(a);
				const Array &array_b = *VariantInternal::get_array(b);
				int asize = array_a.size();
				int bsize = array_b.size();
				Array sum;
				sum.resize(asize + bsize);
				for (int i = 0; i < asize; i++) {
					sum[i] = array_a[i];
				}
				for (int i = 0; i < bsize; i++) {
					sum[i + asize] = array_b[i];
				}

				*dst = sum;
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_ARRAYS_MACRO(OPCODE_OP_CONCAT_ARRAYS);
			// Subraction.
			OPCODE_OP_MATH_NUMBER(SUBTRACT, -);
			OPCODE_OP_MATH_VECTOR(SUBTRACT, -);
			OPCODE_OP_MATH_TYPE(SUBTRACT, -, QUAT, QUAT, QUAT);
			OPCODE_OP_MATH_TYPE(SUBTRACT, -, COLOR, COLOR, COLOR);
			// Multiplication.
			OPCODE_OP_MATH_NUMBER(MULTIPLY, *);
			OPCODE_OP_MATH_TYPE(MULTIPLY, *, TRANSFORM2D, TRANSFORM2D, TRANSFORM2D);
			OPCODE_OP_CALL_TYPE(MULTIPLY, xform, TRANSFORM2D, VECTOR2, VECTOR2);
			OPCODE_OP_MATH_WITH_NUMBERS(MULTIPLY, *, QUAT);
			OPCODE_OP_MATH_TYPE(MULTIPLY, *, QUAT, VECTOR3, QUAT);
			OPCODE_OP_MATH_WITH_NUMBERS_REV(MULTIPLY, *, QUAT);
			OPCODE_OP_MATH_WITH_NUMBERS(MULTIPLY, *, VECTOR2);
			OPCODE_OP_MATH_WITH_NUMBERS(MULTIPLY, *, VECTOR2I);
			OPCODE_OP_MATH_WITH_NUMBERS(MULTIPLY, *, VECTOR3);
			OPCODE_OP_MATH_WITH_NUMBERS(MULTIPLY, *, VECTOR3I);
			OPCODE_OP_MATH_WITH_NUMBERS_REV(MULTIPLY, *, VECTOR2);
			OPCODE_OP_MATH_WITH_NUMBERS_REV(MULTIPLY, *, VECTOR2I);
			OPCODE_OP_MATH_WITH_NUMBERS_REV(MULTIPLY, *, VECTOR3);
			OPCODE_OP_MATH_WITH_NUMBERS_REV(MULTIPLY, *, VECTOR3I);
			OPCODE_OP_MATH_WITH_NUMBERS(MULTIPLY, *, COLOR);
			OPCODE_OP_MATH_WITH_NUMBERS_REV(MULTIPLY, *, COLOR);
			// Division.
			OPCODE_OP_MATH_NUMBER(DIVIDE, /);
			OPCODE_OP_MATH_WITH_NUMBERS(DIVIDE, /, VECTOR2);
			OPCODE_OP_MATH_WITH_NUMBERS(DIVIDE, /, VECTOR2I);
			OPCODE_OP_MATH_WITH_NUMBERS(DIVIDE, /, VECTOR3);
			OPCODE_OP_MATH_WITH_NUMBERS(DIVIDE, /, VECTOR3I);
			OPCODE_OP_MATH_WITH_NUMBERS(DIVIDE, /, COLOR);
			OPCODE_OP_MATH_TYPE(DIVIDE, /, QUAT, FLOAT, QUAT);
			// Modulo.
			OPCODE_OP_MATH_TYPE(MODULO, %, INT, INT, INT);
			// Unary operators.
			OPCODE_OP_UNARY(NEGATE, -, INT);
			OPCODE_OP_UNARY(NEGATE, -, FLOAT);
			OPCODE_OP_UNARY(NEGATE, -, VECTOR2);
			OPCODE_OP_UNARY(NEGATE, -, VECTOR2I);
			OPCODE_OP_UNARY(NEGATE, -, VECTOR3);
			OPCODE_OP_UNARY(NEGATE, -, VECTOR3I);
			OPCODE_OP_UNARY(NEGATE, -, QUAT);
			OPCODE_OP_UNARY(NEGATE, -, COLOR);
			// Bitwise operators.
			OPCODE_OP_UNARY(BIT_NEGATE, ~, INT);
			OPCODE_OP_MATH_TYPE(BIT_AND, &, INT, INT, INT);
			OPCODE_OP_MATH_TYPE(BIT_OR, |, INT, INT, INT);
			OPCODE_OP_MATH_TYPE(BIT_XOR, ^, INT, INT, INT);
			OPCODE_OP_SHIFT(SHIFT_LEFT, <<);
			OPCODE_OP_SHIFT(SHIFT_RIGHT, >>);
			// Logic operators.
			OPCODE_OP_LOGIC_UNARY(NOT, !);
			OPCODE_OP_LOGIC_BINARY(AND, &&);
			OPCODE_OP_LOGIC_BINARY(OR, ||);
			// Comparison operators.
			// Equal.
			OPCODE_ALL_TYPES_BUT_OBJECT_MACRO(OPCODE_EQUAL_TYPE);
			OPCODE_ARRAYS_COMPARISON_MACRO(EQUAL, OPCODE_OP_EQUAL_ARRAYS);
			OPCODE_OP_COMPARISON_BODY(EQUAL_ARRAY, OP_ARRAY_OP_BODY_TEST(!=, false));
			OPCODE_OP_COMPARISON_BODY(EQUAL_OBJECT, OP_OBJECT_EQUAL_BODY_TEST(=));
			OPCODE_EQUAL_TYPES(INT, FLOAT);
			OPCODE_EQUAL_TYPES(FLOAT, INT);
			OPCODE_EQUAL_TYPES(STRING, STRING_NAME);
			OPCODE_EQUAL_TYPES(STRING_NAME, STRING);
			OPCODE_EQUAL_TYPES(STRING, NODE_PATH);
			OPCODE_EQUAL_TYPES(NODE_PATH, STRING);
			// Not equal.
			OPCODE_ALL_TYPES_BUT_OBJECT_MACRO(OPCODE_NOT_EQUAL_TYPE);
			OPCODE_ARRAYS_COMPARISON_MACRO(NOT_EQUAL, OPCODE_OP_NOT_EQUAL_ARRAYS);
			OPCODE_OP_COMPARISON_BODY(NOT_EQUAL_ARRAY, OP_ARRAY_OP_BODY_TEST(==, false));
			OPCODE_OP_COMPARISON_BODY(NOT_EQUAL_OBJECT, OP_OBJECT_EQUAL_BODY_TEST(= !));
			OPCODE_NOT_EQUAL_TYPES(INT, FLOAT);
			OPCODE_NOT_EQUAL_TYPES(FLOAT, INT);
			OPCODE_NOT_EQUAL_TYPES(STRING, STRING_NAME);
			OPCODE_NOT_EQUAL_TYPES(STRING_NAME, STRING);
			OPCODE_NOT_EQUAL_TYPES(STRING, NODE_PATH);
			OPCODE_NOT_EQUAL_TYPES(NODE_PATH, STRING);
			// Less than.
			OPCODE(OPCODE_OP_LESS_BOOL_BOOL) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(a, 1);
				GET_VARIANT_PTR(b, 2);
				GET_VARIANT_PTR(dst, 3);
				VariantInternal::initialize(dst, Variant::BOOL);
				bool ba = *VariantInternal::get_bool(a);
				bool bb = *VariantInternal::get_bool(b);
				*VariantInternal::get_bool(dst) = !ba && bb;
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_OP_COMP_NUMBER(LESS, <);
			OPCODE_OP_COMP_VECTOR(LESS, <);
			// Less than or equal to.
			OPCODE_OP_COMP_NUMBER(LESS_EQUAL, <=);
			OPCODE_OP_COMP_VECTOR(LESS_EQUAL, <=);
			// Greater than.
			OPCODE(OPCODE_OP_GREATER_BOOL_BOOL) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(a, 1);
				GET_VARIANT_PTR(b, 2);
				GET_VARIANT_PTR(dst, 3);
				VariantInternal::initialize(dst, Variant::BOOL);
				bool ba = *VariantInternal::get_bool(a);
				bool bb = *VariantInternal::get_bool(b);
				*VariantInternal::get_bool(dst) = ba && !bb;
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_OP_COMP_NUMBER(GREATER, >);
			OPCODE_OP_COMP_VECTOR(GREATER, >);
			// Greater than or equal to.
			OPCODE_OP_COMP_NUMBER(GREATER_EQUAL, >=);
			OPCODE_OP_COMP_VECTOR(GREATER_EQUAL, >=);

			OPCODE(OPCODE_EXTENDS_TEST) {
				CHECK_SPACE(4);

				GET_VARIANT_PTR(a, 1);
				GET_VARIANT_PTR(b, 2);
				GET_VARIANT_PTR(dst, 3);

#ifdef DEBUG_ENABLED
				if (b->get_type() != Variant::OBJECT || b->operator Object *() == nullptr) {
					err_text = "Right operand of 'is' is not a class.";
					OPCODE_BREAK;
				}
#endif

				bool extends_ok = false;
				if (a->get_type() == Variant::OBJECT && a->operator Object *() != nullptr) {
#ifdef DEBUG_ENABLED
					bool was_freed;
					Object *obj_A = a->get_validated_object_with_check(was_freed);

					if (was_freed) {
						err_text = "Left operand of 'is' is a previously freed instance.";
						OPCODE_BREAK;
					}

					Object *obj_B = b->get_validated_object_with_check(was_freed);

					if (was_freed) {
						err_text = "Right operand of 'is' is a previously freed instance.";
						OPCODE_BREAK;
					}
#else

					Object *obj_A = *a;
					Object *obj_B = *b;
#endif // DEBUG_ENABLED

					GDScript *scr_B = Object::cast_to<GDScript>(obj_B);

					if (scr_B) {
						//if B is a script, the only valid condition is that A has an instance which inherits from the script
						//in other situation, this shoul return false.

						if (obj_A->get_script_instance() && obj_A->get_script_instance()->get_language() == GDScriptLanguage::get_singleton()) {
							GDScript *cmp = static_cast<GDScript *>(obj_A->get_script_instance()->get_script().ptr());
							//bool found=false;
							while (cmp) {
								if (cmp == scr_B) {
									//inherits from script, all ok
									extends_ok = true;
									break;
								}

								cmp = cmp->_base;
							}
						}

					} else {
						GDScriptNativeClass *nc = Object::cast_to<GDScriptNativeClass>(obj_B);

#ifdef DEBUG_ENABLED
						if (!nc) {
							err_text = "Right operand of 'is' is not a class (type: '" + obj_B->get_class() + "').";
							OPCODE_BREAK;
						}
#endif
						extends_ok = ClassDB::is_parent_class(obj_A->get_class_name(), nc->get_name());
					}
				}

				*dst = extends_ok;
				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_IS_BUILTIN) {
				CHECK_SPACE(4);

				GET_VARIANT_PTR(value, 1);
				Variant::Type var_type = (Variant::Type)_code_ptr[ip + 2];
				GET_VARIANT_PTR(dst, 3);

				GD_ERR_BREAK(var_type < 0 || var_type >= Variant::VARIANT_MAX);

				*dst = value->get_type() == var_type;
				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_SET) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(dst, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(value, 3);

				bool valid;
				dst->set(*index, *value, &valid);

#ifdef DEBUG_ENABLED
				if (!valid) {
					String v = index->operator String();
					if (v != "") {
						v = "'" + v + "'";
					} else {
						v = "of type '" + _get_var_type(index) + "'";
					}
					err_text = "Invalid set index " + v + " (on base: '" + _get_var_type(dst) + "') with value of type '" + _get_var_type(value) + "'";
					OPCODE_BREAK;
				}
#endif
				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_GET) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				bool valid;
#ifdef DEBUG_ENABLED
				//allow better error message in cases where src and dst are the same stack position
				Variant ret = src->get(*index, &valid);
#else
				*dst = src->get(*index, &valid);

#endif
#ifdef DEBUG_ENABLED
				if (!valid) {
					String v = index->operator String();
					if (v != "") {
						v = "'" + v + "'";
					} else {
						v = "of type '" + _get_var_type(index) + "'";
					}
					err_text = "Invalid get index " + v + " (on base: '" + _get_var_type(src) + "').";
					OPCODE_BREAK;
				}
				*dst = ret;
#endif
				ip += 4;
			}
			DISPATCH_OPCODE;

			// Typed get.
			OPCODE(OPCODE_GET_STRING_INT) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				String *str = VariantInternal::get_string(src);
				int64_t idx = *VariantInternal::get_int(index);
				if (idx < 0) {
					idx += str->length();
				}
#ifdef DEBUG_ENABLED
				if (idx < 0 || idx >= str->length()) {
					err_text = "Trying to access index past end of string.";
					OPCODE_BREAK;
				}
#endif
				VariantInternal::initialize(dst, Variant::STRING);
				String *dst_str = VariantInternal::get_string(dst);
				memnew_placement(dst_str, String(str->substr(idx, 1)));

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_STRING_FLOAT) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				String *str = VariantInternal::get_string(src);
				int64_t idx = *VariantInternal::get_float(index);
				if (idx < 0) {
					idx += str->length();
				}
#ifdef DEBUG_ENABLED
				if (idx < 0 || idx >= str->length()) {
					err_text = "Trying to access index past end of string.";
					OPCODE_BREAK;
				}
#endif
				VariantInternal::initialize(dst, Variant::STRING);
				String *dst_str = VariantInternal::get_string(dst);
				memnew_placement(dst_str, String(str[idx]));

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector2, VECTOR2, Vector2, INT, 2, FLOAT);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector2, VECTOR2, Vector2, FLOAT, 2, FLOAT);
			OPCODE(OPCODE_GET_VECTOR2_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Vector2 *source = VariantInternal::get_vector2(src);
				String idx = *VariantInternal::get_string(index);
				double result = 0;

				if (idx == "x") {
					result = source->x;
				} else if (idx == "y") {
					result = source->y;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Vector2.)", idx);
					OPCODE_BREAK;
#endif
				}
				VariantInternal::initialize(dst, Variant::FLOAT);
				*VariantInternal::get_float(dst) = result;

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector2i, VECTOR2I, Vector2i, INT, 2, INT);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector2i, VECTOR2I, Vector2i, FLOAT, 2, INT);
			OPCODE(OPCODE_GET_VECTOR2I_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Vector2i *source = VariantInternal::get_vector2i(src);
				String idx = *VariantInternal::get_string(index);
				int result = 0;

				if (idx == "x") {
					result = source->x;
				} else if (idx == "y") {
					result = source->y;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Vector2i.)", idx);
					OPCODE_BREAK;
#endif
				}
				VariantInternal::initialize(dst, Variant::INT);
				*VariantInternal::get_int(dst) = result;

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector3, VECTOR3, Vector3, INT, 3, FLOAT);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector3, VECTOR3, Vector3, FLOAT, 3, FLOAT);
			OPCODE(OPCODE_GET_VECTOR3_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Vector3 *source = VariantInternal::get_vector3(src);
				String idx = *VariantInternal::get_string(index);
				double result = 0;

				if (idx == "x") {
					result = source->x;
				} else if (idx == "y") {
					result = source->y;
				} else if (idx == "z") {
					result = source->z;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Vector3.)", idx);
					OPCODE_BREAK;
#endif
				}
				VariantInternal::initialize(dst, Variant::FLOAT);
				*VariantInternal::get_float(dst) = result;

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector3i, VECTOR3I, Vector3i, INT, 3, INT);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Vector3i, VECTOR3I, Vector3i, FLOAT, 3, INT);
			OPCODE(OPCODE_GET_VECTOR3I_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Vector3i *source = VariantInternal::get_vector3i(src);
				String idx = *VariantInternal::get_string(index);
				int result = 0;

				if (idx == "x") {
					result = source->x;
				} else if (idx == "y") {
					result = source->y;
				} else if (idx == "z") {
					result = source->z;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Vector3i.)", idx);
					OPCODE_BREAK;
#endif
				}
				VariantInternal::initialize(dst, Variant::INT);
				*VariantInternal::get_int(dst) = result;

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_RECT2_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Rect2 *source = VariantInternal::get_rect2(src);
				String idx = *VariantInternal::get_string(index);

				VariantInternal::initialize(dst, Variant::VECTOR2);
				Vector2 *result = VariantInternal::get_vector2(dst);

				if (idx == "position") {
					*result = source->position;
				} else if (idx == "size") {
					*result = source->size;
				} else if (idx == "end") {
					*result = source->size + source->position;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Rect2.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_RECT2I_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Rect2i *source = VariantInternal::get_rect2i(src);
				String idx = *VariantInternal::get_string(index);

				VariantInternal::initialize(dst, Variant::VECTOR2I);
				Vector2i *result = VariantInternal::get_vector2i(dst);

				if (idx == "position") {
					*result = source->position;
				} else if (idx == "size") {
					*result = source->size;
				} else if (idx == "end") {
					*result = source->size + source->position;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Rect2i.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Transform2D, TRANSFORM2D, Transform2D, INT, 3, VECTOR2);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Transform2D, TRANSFORM2D, Transform2D, FLOAT, 3, VECTOR2);
			OPCODE(OPCODE_GET_TRANSFORM2D_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Transform2D *source = VariantInternal::get_transform2d(src);
				String idx = *VariantInternal::get_string(index);

				VariantInternal::initialize(dst, Variant::VECTOR2);
				Vector2 *result = VariantInternal::get_vector2(dst);

				if (idx == "x") {
					*result = source->elements[0];
				} else if (idx == "y") {
					*result = source->elements[1];
				} else if (idx == "origin") {
					*result = source->elements[2];
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Transform2D.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_TRANSFORM_INT) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Transform *source = VariantInternal::get_transform(src);
				int64_t idx = *VariantInternal::get_int(index);

				VariantInternal::initialize(dst, Variant::VECTOR3);
				Vector3 *result = VariantInternal::get_vector3(dst);

				if (idx < 0) {
					idx += 4;
				}
#ifdef DEBUG_ENABLED
				if (idx < 0 || idx >= 4) {
					err_text = vformat(R"(Trying to access index "%d" past end of m_user_type.)", idx);
					OPCODE_BREAK;
				}
#endif
				*result = idx == 3 ? source->origin : source->basis.get_axis(idx);

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_TRANSFORM_FLOAT) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Transform *source = VariantInternal::get_transform(src);
				int64_t idx = *VariantInternal::get_float(index);

				VariantInternal::initialize(dst, Variant::VECTOR3);
				Vector3 *result = VariantInternal::get_vector3(dst);

				if (idx < 0) {
					idx += 4;
				}
#ifdef DEBUG_ENABLED
				if (idx < 0 || idx >= 4) {
					err_text = vformat(R"(Trying to access index "%d" past end of Transform.)", idx);
					OPCODE_BREAK;
				}
#endif
				*result = idx == 3 ? source->origin : source->basis.get_axis(idx);

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_TRANSFORM_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Transform *source = VariantInternal::get_transform(src);
				String idx = *VariantInternal::get_string(index);

				if (idx == "x") {
					VariantInternal::initialize(dst, Variant::BASIS);
					Basis *result = VariantInternal::get_basis(dst);
					*result = source->basis;
				} else if (idx == "origin") {
					VariantInternal::initialize(dst, Variant::VECTOR3);
					Vector3 *result = VariantInternal::get_vector3(dst);
					*result = source->origin;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Transform.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_PLANE_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Plane *source = VariantInternal::get_plane(src);
				String idx = *VariantInternal::get_string(index);

				if (idx == "x") {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->normal.x;
				} else if (idx == "y") {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->normal.y;
				} else if (idx == "z") {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->normal.z;
				} else if (idx == "d") {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->d;
				} else if (idx == "normal") {
					VariantInternal::initialize(dst, Variant::VECTOR3);
					Vector3 *result = VariantInternal::get_vector3(dst);
					*result = source->normal;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Plane.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_QUAT_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Quat *source = VariantInternal::get_quat(src);
				String idx = *VariantInternal::get_string(index);

				VariantInternal::initialize(dst, Variant::FLOAT);
				double *result = VariantInternal::get_float(dst);

				if (idx == "x") {
					*result = source->x;
				} else if (idx == "y") {
					*result = source->y;
				} else if (idx == "z") {
					*result = source->z;
				} else if (idx == "w") {
					*result = source->w;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Transform2D.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_AABB_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				AABB *source = VariantInternal::get_aabb(src);
				String idx = *VariantInternal::get_string(index);

				VariantInternal::initialize(dst, Variant::VECTOR3);
				Vector3 *result = VariantInternal::get_vector3(dst);

				if (idx == "position") {
					*result = source->position;
				} else if (idx == "size") {
					*result = source->size;
				} else if (idx == "end") {
					*result = source->size + source->position;
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on AABB.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Basis, BASIS, Basis, INT, 3, VECTOR3);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Basis, BASIS, Basis, FLOAT, 3, VECTOR3);
			OPCODE(OPCODE_GET_BASIS_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Basis *source = VariantInternal::get_basis(src);
				String idx = *VariantInternal::get_string(index);

				VariantInternal::initialize(dst, Variant::VECTOR3);
				Vector3 *result = VariantInternal::get_vector3(dst);

				if (idx == "x") {
					*result = source->get_axis(0);
				} else if (idx == "y") {
					*result = source->get_axis(1);
				} else if (idx == "z") {
					*result = source->get_axis(2);
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Basis.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE_GET_NUMBER_INDEX_LIMIT(Color, COLOR, Color, INT, 4, FLOAT);
			OPCODE_GET_NUMBER_INDEX_LIMIT(Color, COLOR, Color, FLOAT, 4, FLOAT);
			OPCODE(OPCODE_GET_COLOR_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				Color *source = VariantInternal::get_color(src);
				String idx = *VariantInternal::get_string(index);

				if (idx == "r") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->r;
				} else if (idx == "g") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->g;
				} else if (idx == "b") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->b;
				} else if (idx == "a") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->a;
				} else if (idx == "h") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->get_h();
				} else if (idx == "s") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->get_s();
				} else if (idx == "v") {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->get_v();
				} else if (idx == "r8") {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = (int)Math::round(source->r * 255.0);
				} else if (idx == "g8") {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = (int)Math::round(source->g * 255.0);
				} else if (idx == "b8") {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = (int)Math::round(source->b * 255.0);
				} else if (idx == "a8") {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = (int)Math::round(source->a * 255.0);
#ifdef DEBUG_ENABLED
				} else {
					err_text = vformat(R"(Cannot access index "%s" on Color.)", idx);
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_OBJECT_STRING) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(index, 2);
				GET_VARIANT_PTR(dst, 3);

				bool valid = false;
				Object *source = src->get_validated_object_with_check(valid);
				valid = !valid; // Since the function returns true if freed.
				String idx = *VariantInternal::get_string(index);

				if (source && valid) {
					*dst = source->get(idx, &valid);
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = vformat(R"(Cannot access index "%s" on %s.)", idx, source->to_string());
						OPCODE_BREAK;
					}
#endif
				} else {
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = "Trying to get value from a previously freed instance.";
					} else {
						err_text = "Trying to get value from a null value.";
					}
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_SET_NAMED) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(dst, 1);
				GET_VARIANT_PTR(value, 3);

				int indexname = _code_ptr[ip + 2];

				GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count);
				const StringName *index = &_global_names_ptr[indexname];

				bool valid;
				dst->set_named(*index, *value, &valid);

#ifdef DEBUG_ENABLED
				if (!valid) {
					String err_type;
					err_text = "Invalid set index '" + String(*index) + "' (on base: '" + _get_var_type(dst) + "') with value of type '" + _get_var_type(value) + "'.";
					OPCODE_BREAK;
				}
#endif
				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_GET_NAMED) {
				CHECK_SPACE(4);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(dst, 3);

				int indexname = _code_ptr[ip + 2];

				GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count);
				const StringName *index = &_global_names_ptr[indexname];

				bool valid;
#ifdef DEBUG_ENABLED
				//allow better error message in cases where src and dst are the same stack position
				Variant ret = src->get_named(*index, &valid);

#else
				*dst = src->get_named(*index, &valid);
#endif
#ifdef DEBUG_ENABLED
				if (!valid) {
					if (src->has_method(*index)) {
						err_text = "Invalid get index '" + index->operator String() + "' (on base: '" + _get_var_type(src) + "'). Did you mean '." + index->operator String() + "()' or funcref(obj, \"" + index->operator String() + "\") ?";
					} else {
						err_text = "Invalid get index '" + index->operator String() + "' (on base: '" + _get_var_type(src) + "').";
					}
					OPCODE_BREAK;
				}
				*dst = ret;
#endif
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_VECTOR2) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Vector2, VECTOR2, double, FLOAT);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->x;
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->y;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_VECTOR2I) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Vector2i, VECTOR2I, int64_t, INT);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->x;
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->y;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_VECTOR3) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Vector3, VECTOR3, double, FLOAT);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->x;
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->y;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_VECTOR3I) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Vector3i, VECTOR3I, int64_t, INT);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->x;
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->y;
				} else if (*index == CoreStringNames::singleton->z) {
					*result = source->z;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_RECT2) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Rect2, RECT2, Vector2, VECTOR2);

				if (*index == CoreStringNames::singleton->position) {
					*result = source->position;
				} else if (*index == CoreStringNames::singleton->size) {
					*result = source->size;
				} else if (*index == CoreStringNames::singleton->end) {
					*result = source->size + source->position;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			OPCODE(OPCODE_GET_NAMED_RECT2I) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Rect2i, RECT2I, Vector2i, VECTOR2I);

				if (*index == CoreStringNames::singleton->position) {
					*result = source->position;
				} else if (*index == CoreStringNames::singleton->size) {
					*result = source->size;
				} else if (*index == CoreStringNames::singleton->end) {
					*result = source->size + source->position;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_TRANSFORM) {
				OPCODE_GET_NAMED_START(Transform, TRANSFORM);

				if (*index == CoreStringNames::singleton->basis) {
					VariantInternal::initialize(dst, Variant::BASIS);
					Basis *result = VariantInternal::get_basis(dst);
					*result = source->basis;
				} else if (*index == CoreStringNames::singleton->origin) {
					VariantInternal::initialize(dst, Variant::VECTOR3);
					Vector3 *result = VariantInternal::get_vector3(dst);
					*result = source->origin;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_TRANSFORM2D) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Transform2D, TRANSFORM2D, Vector2, VECTOR2);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->elements[0];
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->elements[1];
				} else if (*index == CoreStringNames::singleton->origin) {
					*result = source->elements[2];
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_PLANE) {
				OPCODE_GET_NAMED_START(Plane, PLANE);

				if (*index == CoreStringNames::singleton->x) {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->normal.x;
				} else if (*index == CoreStringNames::singleton->y) {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->normal.y;
				} else if (*index == CoreStringNames::singleton->z) {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->normal.z;
				} else if (*index == CoreStringNames::singleton->d) {
					VariantInternal::initialize(dst, Variant::FLOAT);
					double *result = VariantInternal::get_float(dst);
					*result = source->d;
				} else if (*index == CoreStringNames::singleton->normal) {
					VariantInternal::initialize(dst, Variant::VECTOR3);
					Vector3 *result = VariantInternal::get_vector3(dst);
					*result = source->normal;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_QUAT) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Quat, QUAT, double, FLOAT);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->x;
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->y;
				} else if (*index == CoreStringNames::singleton->z) {
					*result = source->z;
				} else if (*index == CoreStringNames::singleton->w) {
					*result = source->w;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_AABB) {
				OPCODE_GET_NAMED_START_SINGLE_RET(AABB, AABB, Vector3, VECTOR3);

				if (*index == CoreStringNames::singleton->position) {
					*result = source->position;
				} else if (*index == CoreStringNames::singleton->size) {
					*result = source->size;
				} else if (*index == CoreStringNames::singleton->end) {
					*result = source->size + source->position;
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_BASIS) {
				OPCODE_GET_NAMED_START_SINGLE_RET(Basis, BASIS, Vector3, VECTOR3);

				if (*index == CoreStringNames::singleton->x) {
					*result = source->get_axis(0);
				} else if (*index == CoreStringNames::singleton->y) {
					*result = source->get_axis(1);
				} else if (*index == CoreStringNames::singleton->z) {
					*result = source->get_axis(2);
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_COLOR) {
				OPCODE_GET_NAMED_START(Color, COLOR);

				if (*index == CoreStringNames::singleton->r) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->r;
				} else if (*index == CoreStringNames::singleton->g) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->g;
				} else if (*index == CoreStringNames::singleton->b) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->b;
				} else if (*index == CoreStringNames::singleton->a) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->a;
				} else if (*index == CoreStringNames::singleton->r8) {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = int(Math::round(source->r * 255.0));
				} else if (*index == CoreStringNames::singleton->g8) {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = int(Math::round(source->g * 255.0));
				} else if (*index == CoreStringNames::singleton->b8) {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = int(Math::round(source->b * 255.0));
				} else if (*index == CoreStringNames::singleton->a8) {
					OPCODE_INIT_RESULT(int64_t, INT);
					*result = int(Math::round(source->a * 255.0));
				} else if (*index == CoreStringNames::singleton->h) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->get_h();
				} else if (*index == CoreStringNames::singleton->s) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->get_s();
				} else if (*index == CoreStringNames::singleton->v) {
					OPCODE_INIT_RESULT(double, FLOAT);
					*result = source->get_v();
#ifdef DEBUG_ENABLED
				} else {
					OPCODE_GET_NAMED_ERROR();
#endif
				}
				ip += 4;
			}
			DISPATCH_OPCODE;
			OPCODE(OPCODE_GET_NAMED_OBJECT) {
				CHECK_SPACE(4);

				GET_VARIANT_PTR(src, 1);
				GET_VARIANT_PTR(dst, 3);

				int indexname = _code_ptr[ip + 2];

				GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count);
				const StringName *index = &_global_names_ptr[indexname];

				bool valid = false;
				Object *source = src->get_validated_object_with_check(valid);
				valid = !valid; // Since the function returns true if freed.

				if (source && valid) {
					*dst = source->get(*index, &valid);
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = vformat(R"(Cannot access index "%s" on %s.)", *index, source->to_string());
						OPCODE_BREAK;
					}
#endif
				} else {
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = "Trying to get value from a previously freed instance.";
					} else {
						err_text = "Trying to get value from a null value.";
					}
					OPCODE_BREAK;
#endif
				}

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_SET_MEMBER) {
				CHECK_SPACE(3);
				int indexname = _code_ptr[ip + 1];
				GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count);
				const StringName *index = &_global_names_ptr[indexname];
				GET_VARIANT_PTR(src, 2);

				bool valid;
#ifndef DEBUG_ENABLED
				ClassDB::set_property(p_instance->owner, *index, *src, &valid);
#else
				bool ok = ClassDB::set_property(p_instance->owner, *index, *src, &valid);
				if (!ok) {
					err_text = "Internal error setting property: " + String(*index);
					OPCODE_BREAK;
				} else if (!valid) {
					err_text = "Error setting property '" + String(*index) + "' with value of type " + Variant::get_type_name(src->get_type()) + ".";
					OPCODE_BREAK;
				}
#endif
				ip += 3;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_GET_MEMBER) {
				CHECK_SPACE(3);
				int indexname = _code_ptr[ip + 1];
				GD_ERR_BREAK(indexname < 0 || indexname >= _global_names_count);
				const StringName *index = &_global_names_ptr[indexname];
				GET_VARIANT_PTR(dst, 2);

#ifndef DEBUG_ENABLED
				ClassDB::get_property(p_instance->owner, *index, *dst);
#else
				bool ok = ClassDB::get_property(p_instance->owner, *index, *dst);
				if (!ok) {
					err_text = "Internal error getting property: " + String(*index);
					OPCODE_BREAK;
				}
#endif
				ip += 3;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSIGN) {
				CHECK_SPACE(3);
				GET_VARIANT_PTR(dst, 1);
				GET_VARIANT_PTR(src, 2);

				*dst = *src;

				ip += 3;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSIGN_TRUE) {
				CHECK_SPACE(2);
				GET_VARIANT_PTR(dst, 1);

				*dst = true;

				ip += 2;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSIGN_FALSE) {
				CHECK_SPACE(2);
				GET_VARIANT_PTR(dst, 1);

				*dst = false;

				ip += 2;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSIGN_TYPED_BUILTIN) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(dst, 2);
				GET_VARIANT_PTR(src, 3);

				Variant::Type var_type = (Variant::Type)_code_ptr[ip + 1];
				GD_ERR_BREAK(var_type < 0 || var_type >= Variant::VARIANT_MAX);

				if (src->get_type() != var_type) {
#ifdef DEBUG_ENABLED
					if (Variant::can_convert_strict(src->get_type(), var_type)) {
#endif // DEBUG_ENABLED
						Callable::CallError ce;
						*dst = Variant::construct(var_type, const_cast<const Variant **>(&src), 1, ce);
					} else {
#ifdef DEBUG_ENABLED
						err_text = "Trying to assign value of type '" + Variant::get_type_name(src->get_type()) +
								   "' to a variable of type '" + Variant::get_type_name(var_type) + "'.";
						OPCODE_BREAK;
					}
				} else {
#endif // DEBUG_ENABLED
					*dst = *src;
				}

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSIGN_TYPED_NATIVE) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(dst, 2);
				GET_VARIANT_PTR(src, 3);

#ifdef DEBUG_ENABLED
				GET_VARIANT_PTR(type, 1);
				GDScriptNativeClass *nc = Object::cast_to<GDScriptNativeClass>(type->operator Object *());
				GD_ERR_BREAK(!nc);
				if (src->get_type() != Variant::OBJECT && src->get_type() != Variant::NIL) {
					err_text = "Trying to assign value of type '" + Variant::get_type_name(src->get_type()) +
							   "' to a variable of type '" + nc->get_name() + "'.";
					OPCODE_BREAK;
				}
				Object *src_obj = src->operator Object *();

				if (src_obj && !ClassDB::is_parent_class(src_obj->get_class_name(), nc->get_name())) {
					err_text = "Trying to assign value of type '" + src_obj->get_class_name() +
							   "' to a variable of type '" + nc->get_name() + "'.";
					OPCODE_BREAK;
				}
#endif // DEBUG_ENABLED
				*dst = *src;

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSIGN_TYPED_SCRIPT) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(dst, 2);
				GET_VARIANT_PTR(src, 3);

#ifdef DEBUG_ENABLED
				GET_VARIANT_PTR(type, 1);
				Script *base_type = Object::cast_to<Script>(type->operator Object *());

				GD_ERR_BREAK(!base_type);

				if (src->get_type() != Variant::OBJECT && src->get_type() != Variant::NIL) {
					err_text = "Trying to assign a non-object value to a variable of type '" + base_type->get_path().get_file() + "'.";
					OPCODE_BREAK;
				}

				if (src->get_type() != Variant::NIL && src->operator Object *() != nullptr) {
					ScriptInstance *scr_inst = src->operator Object *()->get_script_instance();
					if (!scr_inst) {
						err_text = "Trying to assign value of type '" + src->operator Object *()->get_class_name() +
								   "' to a variable of type '" + base_type->get_path().get_file() + "'.";
						OPCODE_BREAK;
					}

					Script *src_type = src->operator Object *()->get_script_instance()->get_script().ptr();
					bool valid = false;

					while (src_type) {
						if (src_type == base_type) {
							valid = true;
							break;
						}
						src_type = src_type->get_base_script().ptr();
					}

					if (!valid) {
						err_text = "Trying to assign value of type '" + src->operator Object *()->get_script_instance()->get_script()->get_path().get_file() +
								   "' to a variable of type '" + base_type->get_path().get_file() + "'.";
						OPCODE_BREAK;
					}
				}
#endif // DEBUG_ENABLED

				*dst = *src;

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CAST_TO_BUILTIN) {
				CHECK_SPACE(4);
				Variant::Type to_type = (Variant::Type)_code_ptr[ip + 1];
				GET_VARIANT_PTR(src, 2);
				GET_VARIANT_PTR(dst, 3);

				GD_ERR_BREAK(to_type < 0 || to_type >= Variant::VARIANT_MAX);

				Callable::CallError err;
				*dst = Variant::construct(to_type, (const Variant **)&src, 1, err);

#ifdef DEBUG_ENABLED
				if (err.error != Callable::CallError::CALL_OK) {
					err_text = "Invalid cast: could not convert value to '" + Variant::get_type_name(to_type) + "'.";
					OPCODE_BREAK;
				}
#endif

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CAST_TO_NATIVE) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(to_type, 1);
				GET_VARIANT_PTR(src, 2);
				GET_VARIANT_PTR(dst, 3);

				GDScriptNativeClass *nc = Object::cast_to<GDScriptNativeClass>(to_type->operator Object *());
				GD_ERR_BREAK(!nc);

#ifdef DEBUG_ENABLED
				if (src->get_type() != Variant::OBJECT && src->get_type() != Variant::NIL) {
					err_text = "Invalid cast: can't convert a non-object value to an object type.";
					OPCODE_BREAK;
				}
#endif
				Object *src_obj = src->operator Object *();

				if (src_obj && !ClassDB::is_parent_class(src_obj->get_class_name(), nc->get_name())) {
					*dst = Variant(); // invalid cast, assign NULL
				} else {
					*dst = *src;
				}

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CAST_TO_SCRIPT) {
				CHECK_SPACE(4);
				GET_VARIANT_PTR(to_type, 1);
				GET_VARIANT_PTR(src, 2);
				GET_VARIANT_PTR(dst, 3);

				Script *base_type = Object::cast_to<Script>(to_type->operator Object *());

				GD_ERR_BREAK(!base_type);

#ifdef DEBUG_ENABLED
				if (src->get_type() != Variant::OBJECT && src->get_type() != Variant::NIL) {
					err_text = "Trying to assign a non-object value to a variable of type '" + base_type->get_path().get_file() + "'.";
					OPCODE_BREAK;
				}
#endif

				bool valid = false;

				if (src->get_type() != Variant::NIL && src->operator Object *() != nullptr) {
					ScriptInstance *scr_inst = src->operator Object *()->get_script_instance();

					if (scr_inst) {
						Script *src_type = src->operator Object *()->get_script_instance()->get_script().ptr();

						while (src_type) {
							if (src_type == base_type) {
								valid = true;
								break;
							}
							src_type = src_type->get_base_script().ptr();
						}
					}
				}

				if (valid) {
					*dst = *src; // Valid cast, copy the source object
				} else {
					*dst = Variant(); // invalid cast, assign NULL
				}

				ip += 4;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CONSTRUCT) {
				CHECK_SPACE(2);
				Variant::Type t = Variant::Type(_code_ptr[ip + 1]);
				int argc = _code_ptr[ip + 2];
				CHECK_SPACE(argc + 2);
				Variant **argptrs = call_args;
				for (int i = 0; i < argc; i++) {
					GET_VARIANT_PTR(v, 3 + i);
					argptrs[i] = v;
				}

				GET_VARIANT_PTR(dst, 3 + argc);
				Callable::CallError err;
				*dst = Variant::construct(t, (const Variant **)argptrs, argc, err);

#ifdef DEBUG_ENABLED
				if (err.error != Callable::CallError::CALL_OK) {
					err_text = _get_call_error(err, "'" + Variant::get_type_name(t) + "' constructor", (const Variant **)argptrs);
					OPCODE_BREAK;
				}
#endif

				ip += 4 + argc;
				//construct a basic type
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CONSTRUCT_ARRAY) {
				CHECK_SPACE(1);
				int argc = _code_ptr[ip + 1];
				Array array; //arrays are always shared
				array.resize(argc);
				CHECK_SPACE(argc + 2);

				for (int i = 0; i < argc; i++) {
					GET_VARIANT_PTR(v, 2 + i);
					array[i] = *v;
				}

				GET_VARIANT_PTR(dst, 2 + argc);

				*dst = array;

				ip += 3 + argc;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CONSTRUCT_DICTIONARY) {
				CHECK_SPACE(1);
				int argc = _code_ptr[ip + 1];
				Dictionary dict; //arrays are always shared

				CHECK_SPACE(argc * 2 + 2);

				for (int i = 0; i < argc; i++) {
					GET_VARIANT_PTR(k, 2 + i * 2 + 0);
					GET_VARIANT_PTR(v, 2 + i * 2 + 1);
					dict[*k] = *v;
				}

				GET_VARIANT_PTR(dst, 2 + argc * 2);

				*dst = dict;

				ip += 3 + argc * 2;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CALL_ASYNC)
			OPCODE(OPCODE_CALL_RETURN)
			OPCODE(OPCODE_CALL) {
				CHECK_SPACE(4);
				bool call_ret = _code_ptr[ip] != OPCODE_CALL;
#ifdef DEBUG_ENABLED
				bool call_async = _code_ptr[ip] == OPCODE_CALL_ASYNC;
#endif

				int argc = _code_ptr[ip + 1];
				GET_VARIANT_PTR(base, 2);
				int nameg = _code_ptr[ip + 3];

				GD_ERR_BREAK(nameg < 0 || nameg >= _global_names_count);
				const StringName *methodname = &_global_names_ptr[nameg];

				GD_ERR_BREAK(argc < 0);
				ip += 4;
				CHECK_SPACE(argc + 1);
				Variant **argptrs = call_args;

				for (int i = 0; i < argc; i++) {
					GET_VARIANT_PTR(v, i);
					argptrs[i] = v;
				}

#ifdef DEBUG_ENABLED
				uint64_t call_time = 0;

				if (GDScriptLanguage::get_singleton()->profiling) {
					call_time = OS::get_singleton()->get_ticks_usec();
				}

#endif
				Callable::CallError err;
				if (call_ret) {
					GET_VARIANT_PTR(ret, argc);
					base->call_ptr(*methodname, (const Variant **)argptrs, argc, ret, err);
#ifdef DEBUG_ENABLED
					if (!call_async && ret->get_type() == Variant::OBJECT) {
						// Check if getting a function state without await.
						bool was_freed = false;
						Object *obj = ret->get_validated_object_with_check(was_freed);

						if (was_freed) {
							err_text = "Got a freed object as a result of the call.";
							OPCODE_BREAK;
						}
						if (obj && obj->is_class_ptr(GDScriptFunctionState::get_class_ptr_static())) {
							err_text = R"(Trying to call an async function without "await".)";
							OPCODE_BREAK;
						}
					}
#endif
				} else {
					base->call_ptr(*methodname, (const Variant **)argptrs, argc, nullptr, err);
				}
#ifdef DEBUG_ENABLED
				if (GDScriptLanguage::get_singleton()->profiling) {
					function_call_time += OS::get_singleton()->get_ticks_usec() - call_time;
				}

				if (err.error != Callable::CallError::CALL_OK) {
					String methodstr = *methodname;
					String basestr = _get_var_type(base);

					if (methodstr == "call") {
						if (argc >= 1) {
							methodstr = String(*argptrs[0]) + " (via call)";
							if (err.error == Callable::CallError::CALL_ERROR_INVALID_ARGUMENT) {
								err.argument += 1;
							}
						}
					} else if (methodstr == "free") {
						if (err.error == Callable::CallError::CALL_ERROR_INVALID_METHOD) {
							if (base->is_ref()) {
								err_text = "Attempted to free a reference.";
								OPCODE_BREAK;
							} else if (base->get_type() == Variant::OBJECT) {
								err_text = "Attempted to free a locked object (calling or emitting).";
								OPCODE_BREAK;
							}
						}
					}
					err_text = _get_call_error(err, "function '" + methodstr + "' in base '" + basestr + "'", (const Variant **)argptrs);
					OPCODE_BREAK;
				}
#endif

				//_call_func(nullptr,base,*methodname,ip,argc,p_instance,stack);
				ip += argc + 1;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CALL_BUILT_IN) {
				CHECK_SPACE(4);

				GDScriptFunctions::Function func = GDScriptFunctions::Function(_code_ptr[ip + 1]);
				int argc = _code_ptr[ip + 2];
				GD_ERR_BREAK(argc < 0);

				ip += 3;
				CHECK_SPACE(argc + 1);
				Variant **argptrs = call_args;

				for (int i = 0; i < argc; i++) {
					GET_VARIANT_PTR(v, i);
					argptrs[i] = v;
				}

				GET_VARIANT_PTR(dst, argc);

				Callable::CallError err;

				GDScriptFunctions::call(func, (const Variant **)argptrs, argc, *dst, err);

#ifdef DEBUG_ENABLED
				if (err.error != Callable::CallError::CALL_OK) {
					String methodstr = GDScriptFunctions::get_func_name(func);
					if (dst->get_type() == Variant::STRING) {
						//call provided error string
						err_text = "Error calling built-in function '" + methodstr + "': " + String(*dst);
					} else {
						err_text = _get_call_error(err, "built-in function '" + methodstr + "'", (const Variant **)argptrs);
					}
					OPCODE_BREAK;
				}
#endif
				ip += argc + 1;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_CALL_SELF_BASE) {
				CHECK_SPACE(2);
				int self_fun = _code_ptr[ip + 1];

#ifdef DEBUG_ENABLED
				if (self_fun < 0 || self_fun >= _global_names_count) {
					err_text = "compiler bug, function name not found";
					OPCODE_BREAK;
				}
#endif
				const StringName *methodname = &_global_names_ptr[self_fun];

				int argc = _code_ptr[ip + 2];

				CHECK_SPACE(2 + argc + 1);

				Variant **argptrs = call_args;

				for (int i = 0; i < argc; i++) {
					GET_VARIANT_PTR(v, i + 3);
					argptrs[i] = v;
				}

				GET_VARIANT_PTR(dst, argc + 3);

				const GDScript *gds = _script;

				const Map<StringName, GDScriptFunction *>::Element *E = nullptr;
				while (gds->base.ptr()) {
					gds = gds->base.ptr();
					E = gds->member_functions.find(*methodname);
					if (E) {
						break;
					}
				}

				Callable::CallError err;

				if (E) {
					*dst = E->get()->call(p_instance, (const Variant **)argptrs, argc, err);
				} else if (gds->native.ptr()) {
					if (*methodname != GDScriptLanguage::get_singleton()->strings._init) {
						MethodBind *mb = ClassDB::get_method(gds->native->get_name(), *methodname);
						if (!mb) {
							err.error = Callable::CallError::CALL_ERROR_INVALID_METHOD;
						} else {
							*dst = mb->call(p_instance->owner, (const Variant **)argptrs, argc, err);
						}
					} else {
						err.error = Callable::CallError::CALL_OK;
					}
				} else {
					if (*methodname != GDScriptLanguage::get_singleton()->strings._init) {
						err.error = Callable::CallError::CALL_ERROR_INVALID_METHOD;
					} else {
						err.error = Callable::CallError::CALL_OK;
					}
				}

				if (err.error != Callable::CallError::CALL_OK) {
					String methodstr = *methodname;
					err_text = _get_call_error(err, "function '" + methodstr + "'", (const Variant **)argptrs);

					OPCODE_BREAK;
				}

				ip += 4 + argc;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_AWAIT) {
				CHECK_SPACE(2);

				//do the oneshot connect
				GET_VARIANT_PTR(argobj, 1);

				Signal sig;
				bool is_signal = true;

				{
					Variant result = *argobj;

					if (argobj->get_type() == Variant::OBJECT) {
						bool was_freed = false;
						Object *obj = argobj->get_validated_object_with_check(was_freed);

						if (was_freed) {
							err_text = "Trying to await on a freed object.";
							OPCODE_BREAK;
						}

						// Is this even possible to be null at this point?
						if (obj) {
							if (obj->is_class_ptr(GDScriptFunctionState::get_class_ptr_static())) {
								static StringName completed = _scs_create("completed");
								result = Signal(obj, completed);
							}
						}
					}

					if (result.get_type() != Variant::SIGNAL) {
						ip += 4; // Skip OPCODE_AWAIT_RESUME and its data.
						// The stack pointer should be the same, so we don't need to set a return value.
						is_signal = false;
					} else {
						sig = result;
					}
				}

				if (is_signal) {
					Ref<GDScriptFunctionState> gdfs = memnew(GDScriptFunctionState);
					gdfs->function = this;

					gdfs->state.stack.resize(alloca_size);
					//copy variant stack
					for (int i = 0; i < _stack_size; i++) {
						memnew_placement(&gdfs->state.stack.write[sizeof(Variant) * i], Variant(stack[i]));
					}
					gdfs->state.stack_size = _stack_size;
					gdfs->state.self = self;
					gdfs->state.alloca_size = alloca_size;
					gdfs->state.ip = ip + 2;
					gdfs->state.line = line;
					gdfs->state.script = _script;
					{
						MutexLock lock(GDScriptLanguage::get_singleton()->lock);
						_script->pending_func_states.add(&gdfs->scripts_list);
						if (p_instance) {
							gdfs->state.instance = p_instance;
							p_instance->pending_func_states.add(&gdfs->instances_list);
						} else {
							gdfs->state.instance = nullptr;
						}
					}
#ifdef DEBUG_ENABLED
					gdfs->state.function_name = name;
					gdfs->state.script_path = _script->get_path();
#endif
					gdfs->state.defarg = defarg;
					gdfs->function = this;

					retvalue = gdfs;

					Error err = sig.connect(Callable(gdfs.ptr(), "_signal_callback"), varray(gdfs), Object::CONNECT_ONESHOT);
					if (err != OK) {
						err_text = "Error connecting to signal: " + sig.get_name() + " during await.";
						OPCODE_BREAK;
					}

#ifdef DEBUG_ENABLED
					exit_ok = true;
					awaited = true;
#endif
					OPCODE_BREAK;
				}
			}
			DISPATCH_OPCODE; // Needed for synchronous calls (when result is immediately available).

			OPCODE(OPCODE_AWAIT_RESUME) {
				CHECK_SPACE(2);
#ifdef DEBUG_ENABLED
				if (!p_state) {
					err_text = ("Invalid Resume (bug?)");
					OPCODE_BREAK;
				}
#endif
				GET_VARIANT_PTR(result, 1);
				*result = p_state->result;
				ip += 2;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_JUMP) {
				CHECK_SPACE(2);
				int to = _code_ptr[ip + 1];

				GD_ERR_BREAK(to < 0 || to > _code_size);
				ip = to;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_JUMP_IF) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(test, 1);

				bool result = test->booleanize();

				if (result) {
					int to = _code_ptr[ip + 2];
					GD_ERR_BREAK(to < 0 || to > _code_size);
					ip = to;
				} else {
					ip += 3;
				}
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_JUMP_IF_NOT) {
				CHECK_SPACE(3);

				GET_VARIANT_PTR(test, 1);

				bool result = test->booleanize();

				if (!result) {
					int to = _code_ptr[ip + 2];
					GD_ERR_BREAK(to < 0 || to > _code_size);
					ip = to;
				} else {
					ip += 3;
				}
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_JUMP_TO_DEF_ARGUMENT) {
				CHECK_SPACE(2);
				ip = _default_arg_ptr[defarg];
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_RETURN) {
				CHECK_SPACE(2);
				GET_VARIANT_PTR(r, 1);
				retvalue = *r;
#ifdef DEBUG_ENABLED
				exit_ok = true;
#endif
				OPCODE_BREAK;
			}

			OPCODE(OPCODE_ITERATE_BEGIN) {
				CHECK_SPACE(8); //space for this a regular iterate

				GET_VARIANT_PTR(counter, 1);
				GET_VARIANT_PTR(container, 2);

				bool valid;
				if (!container->iter_init(*counter, valid)) {
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = "Unable to iterate on object of type '" + Variant::get_type_name(container->get_type()) + "'.";
						OPCODE_BREAK;
					}
#endif
					int jumpto = _code_ptr[ip + 3];
					GD_ERR_BREAK(jumpto < 0 || jumpto > _code_size);
					ip = jumpto;
				} else {
					GET_VARIANT_PTR(iterator, 4);

					*iterator = container->iter_get(*counter, valid);
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = "Unable to obtain iterator object of type '" + Variant::get_type_name(container->get_type()) + "'.";
						OPCODE_BREAK;
					}
#endif
					ip += 5; //skip regular iterate which is always next
				}
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ITERATE) {
				CHECK_SPACE(4);

				GET_VARIANT_PTR(counter, 1);
				GET_VARIANT_PTR(container, 2);

				bool valid;
				if (!container->iter_next(*counter, valid)) {
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = "Unable to iterate on object of type '" + Variant::get_type_name(container->get_type()) + "' (type changed since first iteration?).";
						OPCODE_BREAK;
					}
#endif
					int jumpto = _code_ptr[ip + 3];
					GD_ERR_BREAK(jumpto < 0 || jumpto > _code_size);
					ip = jumpto;
				} else {
					GET_VARIANT_PTR(iterator, 4);

					*iterator = container->iter_get(*counter, valid);
#ifdef DEBUG_ENABLED
					if (!valid) {
						err_text = "Unable to obtain iterator object of type '" + Variant::get_type_name(container->get_type()) + "' (but was obtained on first iteration?).";
						OPCODE_BREAK;
					}
#endif
					ip += 5; //loop again
				}
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_ASSERT) {
				CHECK_SPACE(3);

#ifdef DEBUG_ENABLED
				GET_VARIANT_PTR(test, 1);
				bool result = test->booleanize();

				if (!result) {
					String message_str;
					if (_code_ptr[ip + 2] != 0) {
						GET_VARIANT_PTR(message, 2);
						message_str = *message;
					}
					if (message_str.empty()) {
						err_text = "Assertion failed.";
					} else {
						err_text = "Assertion failed: " + message_str;
					}
					OPCODE_BREAK;
				}

#endif
				ip += 3;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_BREAKPOINT) {
#ifdef DEBUG_ENABLED
				if (EngineDebugger::is_active()) {
					GDScriptLanguage::get_singleton()->debug_break("Breakpoint Statement", true);
				}
#endif
				ip += 1;
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_LINE) {
				CHECK_SPACE(2);

				line = _code_ptr[ip + 1];
				ip += 2;

				if (EngineDebugger::is_active()) {
					// line
					bool do_break = false;

					if (EngineDebugger::get_script_debugger()->get_lines_left() > 0) {
						if (EngineDebugger::get_script_debugger()->get_depth() <= 0) {
							EngineDebugger::get_script_debugger()->set_lines_left(EngineDebugger::get_script_debugger()->get_lines_left() - 1);
						}
						if (EngineDebugger::get_script_debugger()->get_lines_left() <= 0) {
							do_break = true;
						}
					}

					if (EngineDebugger::get_script_debugger()->is_breakpoint(line, source)) {
						do_break = true;
					}

					if (do_break) {
						GDScriptLanguage::get_singleton()->debug_break("Breakpoint", true);
					}

					EngineDebugger::get_singleton()->line_poll();
				}
			}
			DISPATCH_OPCODE;

			OPCODE(OPCODE_END) {
#ifdef DEBUG_ENABLED
				exit_ok = true;
#endif
				OPCODE_BREAK;
			}

#if 0 // Enable for debugging.
			default: {
				err_text = "Illegal opcode " + itos(_code_ptr[ip]) + " at address " + itos(ip);
				OPCODE_BREAK;
			}
#endif
		}

		OPCODES_END
#ifdef DEBUG_ENABLED
		if (exit_ok) {
			OPCODE_OUT;
		}
		//error
		// function, file, line, error, explanation
		String err_file;
		if (p_instance && ObjectDB::get_instance(p_instance->owner_id) != nullptr && p_instance->script->is_valid() && p_instance->script->path != "") {
			err_file = p_instance->script->path;
		} else if (script) {
			err_file = script->path;
		}
		if (err_file == "") {
			err_file = "<built-in>";
		}
		String err_func = name;
		if (p_instance && ObjectDB::get_instance(p_instance->owner_id) != nullptr && p_instance->script->is_valid() && p_instance->script->name != "") {
			err_func = p_instance->script->name + "." + err_func;
		}
		int err_line = line;
		if (err_text == "") {
			err_text = "Internal Script Error! - opcode #" + itos(last_opcode) + " (report please).";
		}

		if (!GDScriptLanguage::get_singleton()->debug_break(err_text, false)) {
			// debugger break did not happen

			_err_print_error(err_func.utf8().get_data(), err_file.utf8().get_data(), err_line, err_text.utf8().get_data(), ERR_HANDLER_SCRIPT);
		}

#endif
		OPCODE_OUT;
	}

	OPCODES_OUT
#ifdef DEBUG_ENABLED
	if (GDScriptLanguage::get_singleton()->profiling) {
		uint64_t time_taken = OS::get_singleton()->get_ticks_usec() - function_start_time;
		profile.total_time += time_taken;
		profile.self_time += time_taken - function_call_time;
		profile.frame_total_time += time_taken;
		profile.frame_self_time += time_taken - function_call_time;
		GDScriptLanguage::get_singleton()->script_frame_time += time_taken - function_call_time;
	}

	// Check if this is the last time the function is resuming from await
	// Will be true if never awaited as well
	// When it's the last resume it will postpone the exit from stack,
	// so the debugger knows which function triggered the resume of the next function (if any)
	if (!p_state || awaited) {
		if (EngineDebugger::is_active()) {
			GDScriptLanguage::get_singleton()->exit_function();
		}
#endif

		if (_stack_size) {
			//free stack
			for (int i = 0; i < _stack_size; i++) {
				stack[i].~Variant();
			}
		}

#ifdef DEBUG_ENABLED
	}
#endif

	return retvalue;
}

#undef OPCODE_OP_NUMBER
#undef OPCODE_OP_VECTOR
#undef OPCODE_OP_ARRAYS
#undef OPCODE_OP_TYPE_NUMBER
#undef OPCODE_OP_TYPE_NUMBER_REV
#undef OPCODE_ALL_TYPES

#undef OP_GET_INT
#undef OP_GET_FLOAT
#undef OP_GET_VECTOR2
#undef OP_GET_VECTOR2I
#undef OP_GET_VECTOR3
#undef OP_GET_VECTOR3I
#undef OP_GET_QUAT
#undef OP_GET_COLOR
#undef OP_GET_STRING
#undef OP_GET_ARRAY
#undef OP_GET_BYTE_ARRAY
#undef OP_GET_INT32_ARRAY
#undef OP_GET_INT64_ARRAY
#undef OP_GET_FLOAT32_ARRAY
#undef OP_GET_FLOAT64_ARRAY
#undef OP_GET_STRING_ARRAY
#undef OP_GET_VECTOR2_ARRAY
#undef OP_GET_VECTOR3_ARRAY
#undef OP_GET_COLOR_ARRAY
#undef OP_GET_TRANSFORM
#undef OP_GET_TRANSFORM2D
#undef OPCODE_OP_MATH_TYPE
#undef OPCODE_OP_CALL_TYPE
#undef OPCODE_OP_NO_INIT_TYPE
#undef OPCODE_OP_MATH_NUMBER
#undef OPCODE_OP_MATH_VECTOR
#undef OPCODE_OP_MATH_WITH_NUMBERS
#undef OPCODE_OP_MATH_WITH_NUMBERS_REV
#undef OPCODE_OP_CONCAT_ARRAYS

const int *GDScriptFunction::get_code() const {
	return _code_ptr;
}

int GDScriptFunction::get_code_size() const {
	return _code_size;
}

Variant GDScriptFunction::get_constant(int p_idx) const {
	ERR_FAIL_INDEX_V(p_idx, constants.size(), "<errconst>");
	return constants[p_idx];
}

StringName GDScriptFunction::get_global_name(int p_idx) const {
	ERR_FAIL_INDEX_V(p_idx, global_names.size(), "<errgname>");
	return global_names[p_idx];
}

int GDScriptFunction::get_default_argument_count() const {
	return _default_arg_count;
}

int GDScriptFunction::get_default_argument_addr(int p_idx) const {
	ERR_FAIL_INDEX_V(p_idx, default_arguments.size(), -1);
	return default_arguments[p_idx];
}

GDScriptDataType GDScriptFunction::get_return_type() const {
	return return_type;
}

GDScriptDataType GDScriptFunction::get_argument_type(int p_idx) const {
	ERR_FAIL_INDEX_V(p_idx, argument_types.size(), GDScriptDataType());
	return argument_types[p_idx];
}

StringName GDScriptFunction::get_name() const {
	return name;
}

int GDScriptFunction::get_max_stack_size() const {
	return _stack_size;
}

struct _GDFKC {
	int order;
	List<int> pos;
};

struct _GDFKCS {
	int order;
	StringName id;
	int pos;

	bool operator<(const _GDFKCS &p_r) const {
		return order < p_r.order;
	}
};

void GDScriptFunction::debug_get_stack_member_state(int p_line, List<Pair<StringName, int>> *r_stackvars) const {
	int oc = 0;
	Map<StringName, _GDFKC> sdmap;
	for (const List<StackDebug>::Element *E = stack_debug.front(); E; E = E->next()) {
		const StackDebug &sd = E->get();
		if (sd.line > p_line) {
			break;
		}

		if (sd.added) {
			if (!sdmap.has(sd.identifier)) {
				_GDFKC d;
				d.order = oc++;
				d.pos.push_back(sd.pos);
				sdmap[sd.identifier] = d;

			} else {
				sdmap[sd.identifier].pos.push_back(sd.pos);
			}
		} else {
			ERR_CONTINUE(!sdmap.has(sd.identifier));

			sdmap[sd.identifier].pos.pop_back();
			if (sdmap[sd.identifier].pos.empty()) {
				sdmap.erase(sd.identifier);
			}
		}
	}

	List<_GDFKCS> stackpositions;
	for (Map<StringName, _GDFKC>::Element *E = sdmap.front(); E; E = E->next()) {
		_GDFKCS spp;
		spp.id = E->key();
		spp.order = E->get().order;
		spp.pos = E->get().pos.back()->get();
		stackpositions.push_back(spp);
	}

	stackpositions.sort();

	for (List<_GDFKCS>::Element *E = stackpositions.front(); E; E = E->next()) {
		Pair<StringName, int> p;
		p.first = E->get().id;
		p.second = E->get().pos;
		r_stackvars->push_back(p);
	}
}

GDScriptFunction::GDScriptFunction() :
		function_list(this) {
	_stack_size = 0;
	_call_size = 0;
	rpc_mode = MultiplayerAPI::RPC_MODE_DISABLED;
	name = "<anonymous>";
#ifdef DEBUG_ENABLED
	_func_cname = nullptr;

	{
		MutexLock lock(GDScriptLanguage::get_singleton()->lock);

		GDScriptLanguage::get_singleton()->function_list.add(&function_list);
	}

	profile.call_count = 0;
	profile.self_time = 0;
	profile.total_time = 0;
	profile.frame_call_count = 0;
	profile.frame_self_time = 0;
	profile.frame_total_time = 0;
	profile.last_frame_call_count = 0;
	profile.last_frame_self_time = 0;
	profile.last_frame_total_time = 0;

#endif
}

GDScriptFunction::~GDScriptFunction() {
#ifdef DEBUG_ENABLED

	MutexLock lock(GDScriptLanguage::get_singleton()->lock);

	GDScriptLanguage::get_singleton()->function_list.remove(&function_list);
#endif
}

/////////////////////

Variant GDScriptFunctionState::_signal_callback(const Variant **p_args, int p_argcount, Callable::CallError &r_error) {
	Variant arg;
	r_error.error = Callable::CallError::CALL_OK;

	if (p_argcount == 0) {
		r_error.error = Callable::CallError::CALL_ERROR_TOO_FEW_ARGUMENTS;
		r_error.argument = 1;
		return Variant();
	} else if (p_argcount == 1) {
		//noooneee
	} else if (p_argcount == 2) {
		arg = *p_args[0];
	} else {
		Array extra_args;
		for (int i = 0; i < p_argcount - 1; i++) {
			extra_args.push_back(*p_args[i]);
		}
		arg = extra_args;
	}

	Ref<GDScriptFunctionState> self = *p_args[p_argcount - 1];

	if (self.is_null()) {
		r_error.error = Callable::CallError::CALL_ERROR_INVALID_ARGUMENT;
		r_error.argument = p_argcount - 1;
		r_error.expected = Variant::OBJECT;
		return Variant();
	}

	return resume(arg);
}

bool GDScriptFunctionState::is_valid(bool p_extended_check) const {
	if (function == nullptr) {
		return false;
	}

	if (p_extended_check) {
		MutexLock lock(GDScriptLanguage::get_singleton()->lock);

		// Script gone?
		if (!scripts_list.in_list()) {
			return false;
		}
		// Class instance gone? (if not static function)
		if (state.instance && !instances_list.in_list()) {
			return false;
		}
	}

	return true;
}

Variant GDScriptFunctionState::resume(const Variant &p_arg) {
	ERR_FAIL_COND_V(!function, Variant());
	{
		MutexLock lock(GDScriptLanguage::singleton->lock);

		if (!scripts_list.in_list()) {
#ifdef DEBUG_ENABLED
			ERR_FAIL_V_MSG(Variant(), "Resumed function '" + state.function_name + "()' after await, but script is gone. At script: " + state.script_path + ":" + itos(state.line));
#else
			return Variant();
#endif
		}
		if (state.instance && !instances_list.in_list()) {
#ifdef DEBUG_ENABLED
			ERR_FAIL_V_MSG(Variant(), "Resumed function '" + state.function_name + "()' after await, but class instance is gone. At script: " + state.script_path + ":" + itos(state.line));
#else
			return Variant();
#endif
		}
		// Do these now to avoid locking again after the call
		scripts_list.remove_from_list();
		instances_list.remove_from_list();
	}

	state.result = p_arg;
	Callable::CallError err;
	Variant ret = function->call(nullptr, nullptr, 0, err, &state);

	bool completed = true;

	// If the return value is a GDScriptFunctionState reference,
	// then the function did awaited again after resuming.
	if (ret.is_ref()) {
		GDScriptFunctionState *gdfs = Object::cast_to<GDScriptFunctionState>(ret);
		if (gdfs && gdfs->function == function) {
			completed = false;
			gdfs->first_state = first_state.is_valid() ? first_state : Ref<GDScriptFunctionState>(this);
		}
	}

	function = nullptr; //cleaned up;
	state.result = Variant();

	if (completed) {
		if (first_state.is_valid()) {
			first_state->emit_signal("completed", ret);
		} else {
			emit_signal("completed", ret);
		}

#ifdef DEBUG_ENABLED
		if (EngineDebugger::is_active()) {
			GDScriptLanguage::get_singleton()->exit_function();
		}
#endif
	}

	return ret;
}

void GDScriptFunctionState::_clear_stack() {
	if (state.stack_size) {
		Variant *stack = (Variant *)state.stack.ptr();
		for (int i = 0; i < state.stack_size; i++) {
			stack[i].~Variant();
		}
		state.stack_size = 0;
	}
}

void GDScriptFunctionState::_bind_methods() {
	ClassDB::bind_method(D_METHOD("resume", "arg"), &GDScriptFunctionState::resume, DEFVAL(Variant()));
	ClassDB::bind_method(D_METHOD("is_valid", "extended_check"), &GDScriptFunctionState::is_valid, DEFVAL(false));
	ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "_signal_callback", &GDScriptFunctionState::_signal_callback, MethodInfo("_signal_callback"));

	ADD_SIGNAL(MethodInfo("completed", PropertyInfo(Variant::NIL, "result", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_NIL_IS_VARIANT)));
}

GDScriptFunctionState::GDScriptFunctionState() :
		scripts_list(this),
		instances_list(this) {
	function = nullptr;
}

GDScriptFunctionState::~GDScriptFunctionState() {
	_clear_stack();

	{
		MutexLock lock(GDScriptLanguage::singleton->lock);
		scripts_list.remove_from_list();
		instances_list.remove_from_list();
	}
}

#ifdef DEBUG_ENABLED
static String _get_variant_string(const Variant &p_variant) {
	String txt;
	if (p_variant.get_type() == Variant::STRING) {
		txt = "\"" + String(p_variant) + "\"";
	} else if (p_variant.get_type() == Variant::STRING_NAME) {
		txt = "&\"" + String(p_variant) + "\"";
	} else if (p_variant.get_type() == Variant::NODE_PATH) {
		txt = "^\"" + String(p_variant) + "\"";
	} else if (p_variant.get_type() == Variant::OBJECT) {
		Object *obj = p_variant;
		if (!obj) {
			txt = "null";
		} else {
			GDScriptNativeClass *cls = Object::cast_to<GDScriptNativeClass>(obj);
			if (cls) {
				txt += cls->get_name();
				txt += " (class)";
			} else {
				txt = obj->get_class();
				if (obj->get_script_instance()) {
					txt += "(" + obj->get_script_instance()->get_script()->get_path() + ")";
				}
			}
		}
	} else {
		txt = p_variant;
	}
	return txt;
}

static String _disassemble_address(const GDScript *p_script, const GDScriptFunction &p_function, int p_address) {
	int addr = p_address & GDScriptFunction::ADDR_MASK;

	switch (p_address >> GDScriptFunction::ADDR_BITS) {
		case GDScriptFunction::ADDR_TYPE_SELF: {
			return "self";
		} break;
		case GDScriptFunction::ADDR_TYPE_CLASS: {
			return "class";
		} break;
		case GDScriptFunction::ADDR_TYPE_MEMBER: {
			return "member(" + p_script->debug_get_member_by_index(addr) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_CLASS_CONSTANT: {
			return "class_const(" + p_function.get_global_name(addr) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_LOCAL_CONSTANT: {
			return "const(" + _get_variant_string(p_function.get_constant(addr)) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_STACK: {
			return "stack(" + itos(addr) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_STACK_VARIABLE: {
			return "var_stack(" + itos(addr) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_GLOBAL: {
			return "global(" + _get_variant_string(GDScriptLanguage::get_singleton()->get_global_array()[addr]) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_NAMED_GLOBAL: {
			return "named_global(" + p_function.get_global_name(addr) + ")";
		} break;
		case GDScriptFunction::ADDR_TYPE_NIL: {
			return "nil";
		} break;
	}

	return "<err>";
}

void GDScriptFunction::disassemble(const Vector<String> &p_code_lines) const {
#define DADDR(m_ip) (_disassemble_address(_script, *this, _code_ptr[ip + m_ip]))

	for (int ip = 0; ip < _code_size;) {
		StringBuilder text;
		int incr = 0;

		text += " ";
		text += itos(ip);
		text += ": ";

		// This makes the compiler complain if some opcode is unchecked in the switch.
		Opcode code = Opcode(_code_ptr[ip]);

		switch (code) {
			case OPCODE_OPERATOR: {
				int operation = _code_ptr[ip + 1];

				text += "operator ";

				text += DADDR(4);
				text += " = ";
				text += DADDR(2);
				text += " ";
				text += Variant::get_operator_name(Variant::Operator(operation));
				text += " ";
				text += DADDR(3);

				incr += 5;
			} break;
			case OPCODE_EXTENDS_TEST: {
				text += "is object ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(1);
				text += " is ";
				text += DADDR(2);

				incr += 4;
			} break;
			case OPCODE_IS_BUILTIN: {
				text += "is builtin ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(1);
				text += " is ";
				text += Variant::get_type_name(Variant::Type(_code_ptr[ip + 2]));

				incr += 4;
			} break;
			case OPCODE_SET: {
				text += "set ";
				text += DADDR(1);
				text += "[";
				text += DADDR(2);
				text += "] = ";
				text += DADDR(3);

				incr += 4;
			} break;
			case OPCODE_GET: {
				text += "get ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(1);
				text += "[";
				text += DADDR(2);
				text += "]";

				incr += 4;
			} break;
			case OPCODE_SET_NAMED: {
				text += "set_named ";
				text += DADDR(1);
				text += "[\"";
				text += _global_names_ptr[_code_ptr[ip + 2]];
				text += "\"] = ";
				text += DADDR(3);

				incr += 4;
			} break;
			case OPCODE_GET_NAMED: {
				text += "get_named ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(1);
				text += "[\"";
				text += _global_names_ptr[_code_ptr[ip + 2]];
				text += "\"]";

				incr += 4;
			} break;
			case OPCODE_SET_MEMBER: {
				text += "set_member ";
				text += "[\"";
				text += _global_names_ptr[_code_ptr[ip + 1]];
				text += "\"] = ";
				text += DADDR(2);

				incr += 3;
			} break;
			case OPCODE_GET_MEMBER: {
				text += "get_member ";
				text += DADDR(2);
				text += " = ";
				text += "[\"";
				text += _global_names_ptr[_code_ptr[ip + 1]];
				text += "\"]";

				incr += 3;
			} break;
			case OPCODE_ASSIGN: {
				text += "assign ";
				text += DADDR(1);
				text += " = ";
				text += DADDR(2);

				incr += 3;
			} break;
			case OPCODE_ASSIGN_TRUE: {
				text += "assign ";
				text += DADDR(1);
				text += " = true";

				incr += 2;
			} break;
			case OPCODE_ASSIGN_FALSE: {
				text += "assign ";
				text += DADDR(1);
				text += " = false";

				incr += 2;
			} break;
			case OPCODE_ASSIGN_TYPED_BUILTIN: {
				text += "assign typed builtin (";
				text += Variant::get_type_name((Variant::Type)_code_ptr[ip + 1]);
				text += ") ";
				text += DADDR(2);
				text += " = ";
				text += DADDR(3);

				incr += 4;
			} break;
			case OPCODE_ASSIGN_TYPED_NATIVE: {
				Variant class_name = _constants_ptr[_code_ptr[ip + 1]];
				GDScriptNativeClass *nc = Object::cast_to<GDScriptNativeClass>(class_name.operator Object *());

				text += "assign typed native (";
				text += nc->get_name().operator String();
				text += ") ";
				text += DADDR(2);
				text += " = ";
				text += DADDR(3);

				incr += 4;
			} break;
			case OPCODE_ASSIGN_TYPED_SCRIPT: {
				Variant script = _constants_ptr[_code_ptr[ip + 1]];
				Script *sc = Object::cast_to<Script>(script.operator Object *());

				text += "assign typed script (";
				text += sc->get_path();
				text += ") ";
				text += DADDR(2);
				text += " = ";
				text += DADDR(3);

				incr += 4;
			} break;
			case OPCODE_CAST_TO_BUILTIN: {
				text += "cast builtin ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(2);
				text += " as ";
				text += Variant::get_type_name(Variant::Type(_code_ptr[ip + 1]));

				incr += 4;
			} break;
			case OPCODE_CAST_TO_NATIVE: {
				Variant class_name = _constants_ptr[_code_ptr[ip + 1]];
				GDScriptNativeClass *nc = Object::cast_to<GDScriptNativeClass>(class_name.operator Object *());

				text += "cast native ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(2);
				text += " as ";
				text += nc->get_name();

				incr += 4;
			} break;
			case OPCODE_CAST_TO_SCRIPT: {
				text += "cast ";
				text += DADDR(3);
				text += " = ";
				text += DADDR(2);
				text += " as ";
				text += DADDR(1);

				incr += 4;
			} break;
			case OPCODE_CONSTRUCT: {
				Variant::Type t = Variant::Type(_code_ptr[ip + 1]);
				int argc = _code_ptr[ip + 2];

				text += "construct ";
				text += DADDR(3 + argc);
				text += " = ";

				text += Variant::get_type_name(t) + "(";
				for (int i = 0; i < argc; i++) {
					if (i > 0)
						text += ", ";
					text += DADDR(i + 3);
				}
				text += ")";

				incr = 4 + argc;
			} break;
			case OPCODE_CONSTRUCT_ARRAY: {
				int argc = _code_ptr[ip + 1];
				text += " make_array ";
				text += DADDR(2 + argc);
				text += " = [";

				for (int i = 0; i < argc; i++) {
					if (i > 0)
						text += ", ";
					text += DADDR(2 + i);
				}

				text += "]";

				incr += 3 + argc;
			} break;
			case OPCODE_CONSTRUCT_DICTIONARY: {
				int argc = _code_ptr[ip + 1];
				text += "make_dict ";
				text += DADDR(2 + argc * 2);
				text += " = {";

				for (int i = 0; i < argc; i++) {
					if (i > 0)
						text += ", ";
					text += DADDR(2 + i * 2 + 0);
					text += ": ";
					text += DADDR(2 + i * 2 + 1);
				}

				text += "}";

				incr += 3 + argc * 2;
			} break;
			case OPCODE_CALL:
			case OPCODE_CALL_RETURN:
			case OPCODE_CALL_ASYNC: {
				bool ret = _code_ptr[ip] == OPCODE_CALL_RETURN;
				bool async = _code_ptr[ip] == OPCODE_CALL_ASYNC;

				if (ret) {
					text += "call-ret ";
				} else if (async) {
					text += "call-async ";
				} else {
					text += "call ";
				}

				int argc = _code_ptr[ip + 1];
				if (ret || async) {
					text += DADDR(4 + argc) + " = ";
				}

				text += DADDR(2) + ".";
				text += String(_global_names_ptr[_code_ptr[ip + 3]]);
				text += "(";

				for (int i = 0; i < argc; i++) {
					if (i > 0)
						text += ", ";
					text += DADDR(4 + i);
				}
				text += ")";

				incr = 5 + argc;
			} break;
			case OPCODE_CALL_BUILT_IN: {
				text += "call-built-in ";

				int argc = _code_ptr[ip + 2];
				text += DADDR(3 + argc) + " = ";

				text += GDScriptFunctions::get_func_name(GDScriptFunctions::Function(_code_ptr[ip + 1]));
				text += "(";

				for (int i = 0; i < argc; i++) {
					if (i > 0)
						text += ", ";
					text += DADDR(3 + i);
				}
				text += ")";

				incr = 4 + argc;
			} break;
			case OPCODE_CALL_SELF_BASE: {
				text += "call-self-base ";

				int argc = _code_ptr[ip + 2];
				text += DADDR(3 + argc) + " = ";

				text += _global_names_ptr[_code_ptr[ip + 1]];
				text += "(";

				for (int i = 0; i < argc; i++) {
					if (i > 0)
						text += ", ";
					text += DADDR(3 + i);
				}
				text += ")";

				incr = 4 + argc;
			} break;
			case OPCODE_AWAIT: {
				text += "await ";
				text += DADDR(1);

				incr += 2;
			} break;
			case OPCODE_AWAIT_RESUME: {
				text += "await resume ";
				text += DADDR(1);

				incr = 2;
			} break;
			case OPCODE_JUMP: {
				text += "jump ";
				text += itos(_code_ptr[ip + 1]);

				incr = 2;
			} break;
			case OPCODE_JUMP_IF: {
				text += "jump-if ";
				text += DADDR(1);
				text += " to ";
				text += itos(_code_ptr[ip + 2]);

				incr = 3;
			} break;
			case OPCODE_JUMP_IF_NOT: {
				text += "jump-if-not ";
				text += DADDR(1);
				text += " to ";
				text += itos(_code_ptr[ip + 2]);

				incr = 3;
			} break;
			case OPCODE_JUMP_TO_DEF_ARGUMENT: {
				text += "jump-to-default-argument ";

				incr = 1;
			} break;
			case OPCODE_RETURN: {
				text += "return ";
				text += DADDR(1);

				incr = 2;
			} break;
			case OPCODE_ITERATE_BEGIN: {
				text += "for-init ";
				text += DADDR(4);
				text += " in ";
				text += DADDR(2);
				text += " counter ";
				text += DADDR(1);
				text += " end ";
				text += itos(_code_ptr[ip + 3]);

				incr += 5;
			} break;
			case OPCODE_ITERATE: {
				text += "for-loop ";
				text += DADDR(4);
				text += " in ";
				text += DADDR(2);
				text += " counter ";
				text += DADDR(1);
				text += " end ";
				text += itos(_code_ptr[ip + 3]);

				incr += 5;
			} break;
			case OPCODE_LINE: {
				int line = _code_ptr[ip + 1] - 1;
				if (line >= 0 && line < p_code_lines.size()) {
					text += "line ";
					text += itos(line + 1);
					text += ": ";
					text += p_code_lines[line];
				} else {
					text += "";
				}

				incr += 2;
			} break;
			case OPCODE_ASSERT: {
				text += "assert (";
				text += DADDR(1);
				text += ", ";
				text += DADDR(2);
				text += ")";

				incr += 3;
			} break;
			case OPCODE_BREAKPOINT: {
				text += "breakpoint";

				incr += 1;
			} break;
			case OPCODE_END: {
				text += "== END ==";

				incr += 1;
			} break;
			default:
				break; // FIXME: Remove default case when disassembler is complete.
		}

		ip += incr;
		if (text.get_string_length() > 0) {
			print_line(text.as_string());
		}
	}
}
#endif
