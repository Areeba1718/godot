<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Godot: squish Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Godot
   </div>
   <div id="projectbrief">Game Engine MIT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">squish Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>All squish API functions live in this namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_cluster_fit.html">ClusterFit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_colour_fit.html">ColourFit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_colour_set.html">ColourSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of block colours.  <a href="classsquish_1_1_colour_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_range_fit.html">RangeFit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_single_colour_fit.html">SingleColourFit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsquish_1_1_single_colour_lookup.html">SingleColourLookup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsquish_1_1_source_block.html">SourceBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_sym3x3.html">Sym3x3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_vec3.html">Vec3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsquish_1_1_vec4.html">Vec4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a75d322959cd9654048693f2b5daace7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75d322959cd9654048693f2b5daace7d"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a></td></tr>
<tr class="memdesc:a75d322959cd9654048693f2b5daace7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef a quantity that is a single unsigned byte. <br /></td></tr>
<tr class="separator:a75d322959cd9654048693f2b5daace7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab44b3634a2a1ba86bbf3c1c9230f6850"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850a83080cc9d90864cc1750c9424d43fed5">kDxt1</a> = ( 1 &lt;&lt; 0 ), 
<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850a846ba14b0fe8047d0a15bfb6221719f7">kDxt3</a> = ( 1 &lt;&lt; 1 ), 
<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850ae12be82d563aa405aa4f92ae7ead5609">kDxt5</a> = ( 1 &lt;&lt; 2 ), 
<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850afa36cf5815d79161ebf1239016839173">kColourIterativeClusterFit</a> = ( 1 &lt;&lt; 8 ), 
<br />
&#160;&#160;<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850ac2af50ade4b7a61618e0b02387a7ef95">kColourClusterFit</a> = ( 1 &lt;&lt; 3 ), 
<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850ac364ed6c9376331a73001e516d6cc402">kColourRangeFit</a> = ( 1 &lt;&lt; 4 ), 
<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850a3c1e493e625ace4c17489775e0edb1d9">kColourMetricPerceptual</a> = ( 1 &lt;&lt; 5 ), 
<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850acca19d98df052834d380e4f60b793277">kColourMetricUniform</a> = ( 1 &lt;&lt; 6 ), 
<br />
&#160;&#160;<a class="el" href="namespacesquish.html#ab44b3634a2a1ba86bbf3c1c9230f6850ab7601a1d26924cb1d8b8e71308c3beab">kWeightColourByAlpha</a> = ( 1 &lt;&lt; 7 )
<br />
 }</td></tr>
<tr class="separator:ab44b3634a2a1ba86bbf3c1c9230f6850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeeb58e90956af8b5dcca11805f38a3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeb58e90956af8b5dcca11805f38a3e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CompressAlphaDxt3</b> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *rgba, int mask, void *block)</td></tr>
<tr class="separator:aeeb58e90956af8b5dcca11805f38a3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2a22d92160b31e19ee79c7b7aaf027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada2a22d92160b31e19ee79c7b7aaf027"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DecompressAlphaDxt3</b> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *rgba, void const *block)</td></tr>
<tr class="separator:ada2a22d92160b31e19ee79c7b7aaf027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4034a16e8c217701e19c2cb0f73e98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4034a16e8c217701e19c2cb0f73e98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CompressAlphaDxt5</b> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *rgba, int mask, void *block)</td></tr>
<tr class="separator:a6c4034a16e8c217701e19c2cb0f73e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3559719c7cdd714cf28ab012bf7de3ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3559719c7cdd714cf28ab012bf7de3ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DecompressAlphaDxt5</b> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *rgba, void const *block)</td></tr>
<tr class="separator:a3559719c7cdd714cf28ab012bf7de3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fee70cf1203f1cf2d12248faaabd33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39fee70cf1203f1cf2d12248faaabd33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteColourBlock3</b> (Vec3::Arg start, Vec3::Arg end, <a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *indices, void *block)</td></tr>
<tr class="separator:a39fee70cf1203f1cf2d12248faaabd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fae6109f51f4b0885ae8e55252edfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2fae6109f51f4b0885ae8e55252edfe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteColourBlock4</b> (Vec3::Arg start, Vec3::Arg end, <a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *indices, void *block)</td></tr>
<tr class="separator:ad2fae6109f51f4b0885ae8e55252edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3523d8c6c56d4a9f7879df5f17df9b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3523d8c6c56d4a9f7879df5f17df9b25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DecompressColour</b> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *rgba, void const *block, bool isDxt1)</td></tr>
<tr class="separator:a3523d8c6c56d4a9f7879df5f17df9b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3969628fa4e8e132c07f816d2e38171"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3969628fa4e8e132c07f816d2e38171"></a>
<a class="el" href="classsquish_1_1_sym3x3.html">Sym3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeWeightedCovariance</b> (int n, <a class="el" href="classsquish_1_1_vec3.html">Vec3</a> const *points, float const *weights)</td></tr>
<tr class="separator:ab3969628fa4e8e132c07f816d2e38171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2055dceaa7cb4326383f730d8b5d1ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2055dceaa7cb4326383f730d8b5d1ef"></a>
<a class="el" href="classsquish_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ComputePrincipleComponent</b> (<a class="el" href="classsquish_1_1_sym3x3.html">Sym3x3</a> const &amp;matrix)</td></tr>
<tr class="separator:ad2055dceaa7cb4326383f730d8b5d1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa555c456815047392c19163562f7ab57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa555c456815047392c19163562f7ab57"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>LengthSquared</b> (Vec3::Arg v)</td></tr>
<tr class="separator:aa555c456815047392c19163562f7ab57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025c279289d7721ee195c84f83cc0535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#a025c279289d7721ee195c84f83cc0535">Compress</a> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *rgba, void *block, int flags)</td></tr>
<tr class="memdesc:a025c279289d7721ee195c84f83cc0535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses a 4x4 block of pixels.  <a href="#a025c279289d7721ee195c84f83cc0535">More...</a><br /></td></tr>
<tr class="separator:a025c279289d7721ee195c84f83cc0535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677a0268c445e086e07223fe44cd679b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#a677a0268c445e086e07223fe44cd679b">CompressMasked</a> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *rgba, int mask, void *block, int flags)</td></tr>
<tr class="memdesc:a677a0268c445e086e07223fe44cd679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses a 4x4 block of pixels.  <a href="#a677a0268c445e086e07223fe44cd679b">More...</a><br /></td></tr>
<tr class="separator:a677a0268c445e086e07223fe44cd679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd48665f8351fdbb930e32b0f99ba167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#afd48665f8351fdbb930e32b0f99ba167">Decompress</a> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *rgba, void const *block, int flags)</td></tr>
<tr class="memdesc:afd48665f8351fdbb930e32b0f99ba167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses a 4x4 block of pixels.  <a href="#afd48665f8351fdbb930e32b0f99ba167">More...</a><br /></td></tr>
<tr class="separator:afd48665f8351fdbb930e32b0f99ba167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac72ca52c17155486b36b94d32651d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#a5ac72ca52c17155486b36b94d32651d9">GetStorageRequirements</a> (int width, int height, int flags)</td></tr>
<tr class="memdesc:a5ac72ca52c17155486b36b94d32651d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the amount of compressed storage required.  <a href="#a5ac72ca52c17155486b36b94d32651d9">More...</a><br /></td></tr>
<tr class="separator:a5ac72ca52c17155486b36b94d32651d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab826a9c66fbe555db69ad0e6712d0edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#ab826a9c66fbe555db69ad0e6712d0edb">CompressImage</a> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *rgba, int width, int height, void *blocks, int flags)</td></tr>
<tr class="memdesc:ab826a9c66fbe555db69ad0e6712d0edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses an image in memory.  <a href="#ab826a9c66fbe555db69ad0e6712d0edb">More...</a><br /></td></tr>
<tr class="separator:ab826a9c66fbe555db69ad0e6712d0edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b6c4e5ec6f4b98e81d5e5e4e5e88b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesquish.html#a4f8b6c4e5ec6f4b98e81d5e5e4e5e88b">DecompressImage</a> (<a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *rgba, int width, int height, void const *blocks, int flags)</td></tr>
<tr class="memdesc:a4f8b6c4e5ec6f4b98e81d5e5e4e5e88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses an image in memory.  <a href="#a4f8b6c4e5ec6f4b98e81d5e5e4e5e88b">More...</a><br /></td></tr>
<tr class="separator:a4f8b6c4e5ec6f4b98e81d5e5e4e5e88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>All squish API functions live in this namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850a83080cc9d90864cc1750c9424d43fed5"></a>kDxt1&#160;</td><td class="fielddoc">
<p>Use DXT1 compression. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850a846ba14b0fe8047d0a15bfb6221719f7"></a>kDxt3&#160;</td><td class="fielddoc">
<p>Use DXT3 compression. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850ae12be82d563aa405aa4f92ae7ead5609"></a>kDxt5&#160;</td><td class="fielddoc">
<p>Use DXT5 compression. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850afa36cf5815d79161ebf1239016839173"></a>kColourIterativeClusterFit&#160;</td><td class="fielddoc">
<p>Use a very slow but very high quality colour compressor. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850ac2af50ade4b7a61618e0b02387a7ef95"></a>kColourClusterFit&#160;</td><td class="fielddoc">
<p>Use a slow but high quality colour compressor (the default). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850ac364ed6c9376331a73001e516d6cc402"></a>kColourRangeFit&#160;</td><td class="fielddoc">
<p>Use a fast but low quality colour compressor. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850a3c1e493e625ace4c17489775e0edb1d9"></a>kColourMetricPerceptual&#160;</td><td class="fielddoc">
<p>Use a perceptual metric for colour error (the default). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850acca19d98df052834d380e4f60b793277"></a>kColourMetricUniform&#160;</td><td class="fielddoc">
<p>Use a uniform metric for colour error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab44b3634a2a1ba86bbf3c1c9230f6850ab7601a1d26924cb1d8b8e71308c3beab"></a>kWeightColourByAlpha&#160;</td><td class="fielddoc">
<p>Weight the colour by alpha during cluster fit (disabled by default). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a025c279289d7721ee195c84f83cc0535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squish::Compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *&#160;</td>
          <td class="paramname"><em>rgba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compresses a 4x4 block of pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>The rgba values of the 16 source pixels. </td></tr>
    <tr><td class="paramname">block</td><td>Storage for the compressed DXT block. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_compression.html">Compression</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<p>The source pixels should be presented as a contiguous array of 16 rgba values, with each component as 1 byte each. In memory this should be: </p><pre class="fragment">{ r1, g1, b1, a1, .... , r16, g16, b16, a16 }
</pre><p>The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, however, DXT1 will be used by default if none is specified. When using DXT1 compression, 8 bytes of storage are required for the compressed DXT block. DXT3 and DXT5 compression require 16 bytes of storage per block.</p>
<p>The flags parameter can also specify a preferred colour compressor and colour error metric to use when fitting the RGB components of the data. Possible colour compressors are: kColourClusterFit (the default), kColourRangeFit or kColourIterativeClusterFit. Possible colour error metrics are: kColourMetricPerceptual (the default) or kColourMetricUniform. If no flags are specified in any particular category then the default will be used. Unknown flags are ignored.</p>
<p>When using kColourClusterFit, an additional flag can be specified to weight the colour of each pixel by its alpha value. For images that are rendered using alpha blending, this can significantly increase the perceived quality. </p>

</div>
</div>
<a class="anchor" id="ab826a9c66fbe555db69ad0e6712d0edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squish::CompressImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *&#160;</td>
          <td class="paramname"><em>rgba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compresses an image in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>The pixels of the source. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the source image. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the source image. </td></tr>
    <tr><td class="paramname">blocks</td><td>Storage for the compressed output. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_compression.html">Compression</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<p>The source pixels should be presented as a contiguous array of width*height rgba values, with each component as 1 byte each. In memory this should be: </p><pre class="fragment">{ r1, g1, b1, a1, .... , rn, gn, bn, an } for n = width*height
</pre><p>The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, however, DXT1 will be used by default if none is specified. When using DXT1 compression, 8 bytes of storage are required for each compressed DXT block. DXT3 and DXT5 compression require 16 bytes of storage per block.</p>
<p>The flags parameter can also specify a preferred colour compressor and colour error metric to use when fitting the RGB components of the data. Possible colour compressors are: kColourClusterFit (the default), kColourRangeFit or kColourIterativeClusterFit. Possible colour error metrics are: kColourMetricPerceptual (the default) or kColourMetricUniform. If no flags are specified in any particular category then the default will be used. Unknown flags are ignored.</p>
<p>When using kColourClusterFit, an additional flag can be specified to weight the colour of each pixel by its alpha value. For images that are rendered using alpha blending, this can significantly increase the perceived quality.</p>
<p>Internally this function calls <a class="el" href="namespacesquish.html#a025c279289d7721ee195c84f83cc0535" title="Compresses a 4x4 block of pixels. ">squish::Compress</a> for each block. To see how much memory is required in the compressed image, use <a class="el" href="namespacesquish.html#a5ac72ca52c17155486b36b94d32651d9" title="Computes the amount of compressed storage required. ">squish::GetStorageRequirements</a>. </p>

</div>
</div>
<a class="anchor" id="a677a0268c445e086e07223fe44cd679b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squish::CompressMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> const *&#160;</td>
          <td class="paramname"><em>rgba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compresses a 4x4 block of pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>The rgba values of the 16 source pixels. </td></tr>
    <tr><td class="paramname">mask</td><td>The valid pixel mask. </td></tr>
    <tr><td class="paramname">block</td><td>Storage for the compressed DXT block. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_compression.html">Compression</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<p>The source pixels should be presented as a contiguous array of 16 rgba values, with each component as 1 byte each. In memory this should be: </p><pre class="fragment">{ r1, g1, b1, a1, .... , r16, g16, b16, a16 }
</pre><p>The mask parameter enables only certain pixels within the block. The lowest bit enables the first pixel and so on up to the 16th bit. Bits beyond the 16th bit are ignored. Pixels that are not enabled are allowed to take arbitrary colours in the output block. An example of how this can be used is in the CompressImage function to disable pixels outside the bounds of the image when the width or height is not divisible by 4.</p>
<p>The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, however, DXT1 will be used by default if none is specified. When using DXT1 compression, 8 bytes of storage are required for the compressed DXT block. DXT3 and DXT5 compression require 16 bytes of storage per block.</p>
<p>The flags parameter can also specify a preferred colour compressor and colour error metric to use when fitting the RGB components of the data. Possible colour compressors are: kColourClusterFit (the default), kColourRangeFit or kColourIterativeClusterFit. Possible colour error metrics are: kColourMetricPerceptual (the default) or kColourMetricUniform. If no flags are specified in any particular category then the default will be used. Unknown flags are ignored.</p>
<p>When using kColourClusterFit, an additional flag can be specified to weight the colour of each pixel by its alpha value. For images that are rendered using alpha blending, this can significantly increase the perceived quality. </p>

</div>
</div>
<a class="anchor" id="afd48665f8351fdbb930e32b0f99ba167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squish::Decompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *&#160;</td>
          <td class="paramname"><em>rgba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses a 4x4 block of pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>Storage for the 16 decompressed pixels. </td></tr>
    <tr><td class="paramname">block</td><td>The compressed DXT block. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_compression.html">Compression</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<p>The decompressed pixels will be written as a contiguous array of 16 rgba values, with each component as 1 byte each. In memory this is: </p><pre class="fragment">{ r1, g1, b1, a1, .... , r16, g16, b16, a16 }
</pre><p>The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, however, DXT1 will be used by default if none is specified. All other flags are ignored. </p>

</div>
</div>
<a class="anchor" id="a4f8b6c4e5ec6f4b98e81d5e5e4e5e88b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squish::DecompressImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesquish.html#a75d322959cd9654048693f2b5daace7d">u8</a> *&#160;</td>
          <td class="paramname"><em>rgba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses an image in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>Storage for the decompressed pixels. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the source image. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the source image. </td></tr>
    <tr><td class="paramname">blocks</td><td>The compressed DXT blocks. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_compression.html">Compression</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<p>The decompressed pixels will be written as a contiguous array of width*height 16 rgba values, with each component as 1 byte each. In memory this is: </p><pre class="fragment">{ r1, g1, b1, a1, .... , rn, gn, bn, an } for n = width*height
</pre><p>The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, however, DXT1 will be used by default if none is specified. All other flags are ignored.</p>
<p>Internally this function calls <a class="el" href="namespacesquish.html#afd48665f8351fdbb930e32b0f99ba167" title="Decompresses a 4x4 block of pixels. ">squish::Decompress</a> for each block. </p>

</div>
</div>
<a class="anchor" id="a5ac72ca52c17155486b36b94d32651d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int squish::GetStorageRequirements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the amount of compressed storage required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the image. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_compression.html">Compression</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<p>The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, however, DXT1 will be used by default if none is specified. All other flags are ignored.</p>
<p>Most DXT images will be a multiple of 4 in each dimension, but this function supports arbitrary size images by allowing the outer blocks to be only partially used. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 21 2015 13:25:09 for Godot by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
