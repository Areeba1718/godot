<?xml version="1.0" encoding="UTF-8" ?>
<class name="CPUParticle3D" inherits="RefCounted" version="4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../class.xsd">
	<brief_description>
		Contains information about an individual particle from a [CPUParticles3D] system.
	</brief_description>
	<description>
		Contains information about an individual particle from a [CPUParticles3D] system.
		[CPUParticle3D] is emitted as an [Array] of objects by the [signal CPUParticles3D.particles_updated] signal.
		This can be used to make nodes (such as [Light3D]s, [AudioStreamPlayer3D]s or other [CPUParticles3D]s) follow particles individually for advanced effects.
		[b]Note:[/b] To avoid performance issues, it's recommended to only use this feature with low numbers of particles (typically a few dozen at most).
		[b]Example of placing [OmniLight3D]s to follow particles automatically and change color over time:[/b]
		[codeblock]
		extends CPUParticles3D

		# Used to keep track of light nodes added as children more easily.
		var lights = []

		func _ready():
		    for i in amount:
		        var light = OmniLight3D.new()
		        lights.push_back(light)
		        add_child(light)

		    particles_updated.connect(_on_cpu_particles_3d_particles_updated)


		func _on_cpu_particles_3d_particles_updated(particles):
		    # Only update light positions if all light nodes have been added first.
		    if lights.size() &gt;= particles.size():
		        for particle_idx in particles.size():
		            lights[particle_idx].visible = particles[particle_idx].is_active()

		            # Change the light's color over the particle's lifetime.
		            lights[particle_idx].light_color.r = particles[particle_idx].get_phase()
		            lights[particle_idx].light_color.g = 1.0 - particles[particle_idx].get_phase()
		            lights[particle_idx].light_color.b = 1.0 - particles[particle_idx].get_phase()
		            lights[particle_idx].light_energy = 2.0 - particles[particle_idx].get_phase() * 2.0

		            # Increase the light's range over the particle's lifetime.
		            lights[particle_idx].omni_range = particles[particle_idx].get_phase() * 5.0

		            # Move lights to follow particles.
		            if local_coords:
		                lights[particle_idx].position = particles[particle_idx].get_transform().origin
		            else:
		                lights[particle_idx].global_transform.origin = particles[particle_idx].get_transform().origin
		[/codeblock]
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="get_color" qualifiers="const">
			<return type="Color" />
			<description>
				Returns the particle's current color. This is the color defined by [member CPUParticles3D.color] or [member CPUParticles3D.color_initial_ramp], which is then multiplied by [member CPUParticles3D.color_ramp] over the particle's lifetime.
				[b]Note:[/b] [method get_color] does not take the material albedo color or mesh's original vertex color into account.
			</description>
		</method>
		<method name="get_phase" qualifiers="const">
			<return type="float" />
			<description>
				Returns the particle's lifetime percentage. This is close to [code]0.0[/code] when the particle is freshly spawned, and close to [code]1.0[/code] when the particle is about to expire.
				[b]Note:[/b] If the particle is inactive ([method is_active] returns [code]false[/code]), [method get_phase] returns [code]0.0[/code].
			</description>
		</method>
		<method name="get_seed" qualifiers="const">
			<return type="int" />
			<description>
				Returns the particle's random seed (a 32-bit [i]unsigned[/i] integer) within the particle system. This can be used to uniquely identify a given particle within the particle system during its lifetime.
				Since the seed is uniformly distributed, [method get_seed] can be used to selectively apply effects to certain particles only. This can be useful to improve performance by applying expensive effects to lower amounts of particles:
				[codeblock]
				# `particles` is an array of CPUParticle3D results from CPUParticles3D's `particles_updated` signal.
				for particle in particles:
				    # The maximum value of a 32-bit unsigned integer is (2 ^ 32) - 1, which is roughly 4.2 billion.
				    if particle.get_seed() &lt;= 2 &lt;&lt; 31:  # Lower than roughly 2.1 billion.
				        # Apply an effect to roughly 50% of particles here (the exact amount is random and varies constantly).
				        pass
				[/codeblock]
				[b]Note:[/b] When a particle respawns after expiring, it will generate and use a different seed. This means [method get_seed] cannot be used to identify a given particle after it respawns.
			</description>
		</method>
		<method name="get_transform" qualifiers="const">
			<return type="Transform3D" />
			<description>
				Returns the particle's transform. If you're only interested in the particle's position, use [code]get_transform().origin[/code].
				[b]Note:[/b] If [member CPUParticles3D.local_coords] is [code]true[/code], you'll want to set nodes' [i]local[/i] transform when moving them to match particle positions. If [member CPUParticles3D.local_coords] is [code]false[/code], you'll want to set nodes' [i]global[/i] transform when moving them to match particle positions.
				[b]Note:[/b] If the particle is inactive ([method is_active] returns [code]false[/code]), [method get_transform] returns an identity [code]Transform3D()[/code].
			</description>
		</method>
		<method name="get_velocity" qualifiers="const">
			<return type="Vector3" />
			<description>
				Returns the particle's speed in units per second on each axis.
				[b]Note:[/b] If the particle is inactive ([method is_active] returns [code]false[/code]), [method get_velocity] returns [code]Vector3(0, 0, 0)[/code].
			</description>
		</method>
		<method name="is_active" qualifiers="const">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if the particle is currently alive, [code]false[/code] otherwise.
				Typically, all particles are active except in two scenarios:
				- The particle system has just started and its [member CPUParticles3D.explosiveness] is not equal to [code]1.0[/code]. Therefore, there are less active particles than the [member CPUParticles3D.amount] configured.
				- The particle system has just had [member CPUParticles3D.emitting] set to [code]false[/code]. After all particles have expired (plus some additional time), the signal will no longer be emitted.
			</description>
		</method>
	</methods>
</class>
